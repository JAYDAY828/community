<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>홍또연 블로그 비서 (Pro)</title>
    <meta name="description" content="홍또연 블로그 작성을 돕는 보조 도구">
    <meta name="theme-color" content="#db2777">
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='14' fill='%23db2777'/%3E%3Ctext x='50%25' y='55%25' dominant-baseline='middle' text-anchor='middle' font-size='34'%3E%E2%9C%8D%EF%B8%8F%3C/text%3E%3C/svg%3E">
    <link rel="apple-touch-icon"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='14' fill='%23db2777'/%3E%3Ctext x='50%25' y='55%25' dominant-baseline='middle' text-anchor='middle' font-size='34'%3E%E2%9C%8D%EF%B8%8F%3C/text%3E%3C/svg%3E">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Markdown Parser -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- HEIC Converter -->
    <script src="https://cdn.jsdelivr.net/npm/heic2any/dist/heic2any.min.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap"
        rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
        }

        .prose h1 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            color: #1f2937;
        }

        .prose h2 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: #374151;
        }

        .prose p {
            margin-bottom: 1rem;
            line-height: 1.7;
            color: #4b5563;
        }

        .prose strong {
            color: #111827;
            font-weight: 600;
        }

        .prose ul {
            list-style-type: disc;
            padding-left: 1.5rem;
            margin-bottom: 1rem;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #db2777;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background-color: #f3f4f6;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #e5e7eb;
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background-color: #d1d5db;
        }

        .tab-active {
            border-bottom: 2px solid #db2777;
            color: #db2777;
            font-weight: 700;
        }

        .tab-inactive {
            color: #6b7280;
            font-weight: 500;
        }

        .tab-inactive:hover {
            color: #374151;
        }

        #publishPanelContent {
            transition: max-height 0.24s ease, opacity 0.2s ease;
        }

        @media (max-width: 1023.98px) {
            #publishPanelContent {
                max-height: 0;
                opacity: 0;
                overflow-y: hidden;
            }

            #publishPanelContent.is-open {
                max-height: min(60vh, 560px);
                opacity: 1;
                overflow-y: auto;
            }
        }

        @media (min-width: 1024px) {
            #publishPanelContent {
                max-height: none !important;
                opacity: 1 !important;
                overflow-y: auto !important;
            }
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-800 h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-white border-b border-gray-200 shadow-sm z-20">
        <div class="px-6 py-4 flex justify-between items-center">
            <div class="flex items-center gap-2">
                <span class="inline-flex w-8 h-8" aria-hidden="true">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" class="w-8 h-8">
                        <rect width="64" height="64" rx="14" fill="#db2777"></rect>
                        <text x="50%" y="55%" dominant-baseline="middle" text-anchor="middle" font-size="34">✍️</text>
                    </svg>
                </span>
                <h1 class="text-xl font-bold text-gray-800">홍또연 블로그 비서</h1>
                <span class="bg-pink-100 text-pink-700 text-xs px-2 py-1 rounded-full font-bold">PRO</span>
            </div>
            <button onclick="toggleSettings()"
                class="text-gray-500 hover:text-gray-700 p-2 rounded-full hover:bg-gray-100 transition flex items-center gap-1">
                <span>⚙️ 설정</span>
            </button>
        </div>

        <!-- Tabs -->
        <div class="flex px-6 gap-8">
            <button onclick="switchTab('writer')" id="tab-writer" class="pb-3 px-1 transition-all tab-active">
                ✍️ 글쓰기
            </button>
            <button onclick="switchTab('manager')" id="tab-manager" class="pb-3 px-1 transition-all tab-inactive">
                📊 관리 도구
            </button>
        </div>
    </header>

    <!-- Settings Modal -->
    <div id="settingsModal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div
            class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-3xl mx-4 transform transition-all scale-100 max-h-[90vh] overflow-y-auto custom-scrollbar">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-lg font-bold flex items-center gap-2">⚙️ 설정</h2>
                <button onclick="toggleSettings()" class="text-gray-400 hover:text-gray-600">✕</button>
            </div>

            <div class="grid grid-cols-1 xl:grid-cols-2 gap-5">
                <section class="rounded-xl border border-gray-200 p-4">
                    <h3 class="text-base font-bold text-gray-800 mb-2 flex items-center gap-2">🔑 API 키 관리</h3>
                    <p class="text-sm text-gray-500 mb-3 leading-relaxed">
                        Gemini API 키를 여러 개 저장해두고 상황에 맞게 바꿔 쓸 수 있습니다.
                        <a href="https://aistudio.google.com/app/apikey" target="_blank"
                            class="text-pink-500 font-medium hover:underline ml-1">무료 키 발급</a>
                    </p>

                    <div class="space-y-2">
                        <input type="text" id="apiKeyAliasInput" placeholder="키 이름(선택) 예: 개인계정 A"
                            class="w-full border border-gray-300 rounded-lg p-2.5 focus:ring-2 focus:ring-pink-500 focus:border-pink-500 outline-none transition shadow-sm">
                        <input type="password" id="apiKeyInput" placeholder="AIzaSy..."
                            class="w-full border border-gray-300 rounded-lg p-2.5 focus:ring-2 focus:ring-pink-500 focus:border-pink-500 outline-none transition shadow-sm">
                        <button id="saveBtn" onclick="saveApiKey()"
                            class="w-full px-4 py-2.5 bg-pink-600 text-white rounded-lg hover:bg-pink-700 transition font-medium shadow-sm">
                            키 저장
                        </button>
                    </div>

                    <div class="mt-4 pt-4 border-t border-gray-200">
                        <label for="apiKeySelect" class="block text-xs font-semibold text-gray-600 mb-2">저장된 키</label>
                        <select id="apiKeySelect"
                            class="w-full border border-gray-300 rounded-lg p-2.5 text-sm focus:ring-2 focus:ring-pink-500 focus:border-pink-500 outline-none"></select>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 mt-2">
                            <button id="useSelectedBtn" onclick="activateSelectedApiKey()"
                                class="px-4 py-2.5 bg-gray-800 text-white rounded-lg hover:bg-black transition text-sm font-semibold">선택 키 사용</button>
                            <button id="disconnectBtn" onclick="disconnectApiKey()"
                                class="px-4 py-2.5 bg-white text-gray-700 border border-gray-300 rounded-lg hover:bg-gray-50 transition text-sm font-semibold">선택 키 삭제</button>
                        </div>
                        <p id="apiKeyStatusText" class="text-xs text-gray-500 mt-2">활성 API 키가 없습니다.</p>
                    </div>
                </section>

                <section class="rounded-xl border border-gray-200 p-4">
                    <h3 class="text-base font-bold text-gray-800 mb-2 flex items-center gap-2">🗣️ 말투 프로필 설정</h3>
                    <p class="text-sm text-gray-500 mb-3 leading-relaxed">
                        글쓰기 비서와 관리 도구 전역에 적용할 말투 프로필을 여기서 관리합니다.
                    </p>
                    <div class="space-y-2">
                        <input type="text" id="blogIdInput" placeholder="네이버 아이디 또는 블로그 주소를 입력하세요"
                            class="w-full border border-gray-300 rounded-lg p-2.5 focus:ring-2 focus:ring-pink-500 outline-none text-sm">
                        <div class="grid grid-cols-1 sm:grid-cols-3 gap-2">
                            <button onclick="saveBlogId()"
                                class="bg-gray-800 text-white px-4 py-2.5 rounded-lg font-semibold hover:bg-black transition text-sm">ID 저장</button>
                            <button onclick="refreshToneProfile()"
                                class="bg-pink-600 text-white px-4 py-2.5 rounded-lg font-semibold hover:bg-pink-700 transition text-sm whitespace-nowrap">프로필 갱신</button>
                            <button onclick="resetToneProfile()"
                                class="bg-white border border-gray-300 text-gray-700 px-4 py-2.5 rounded-lg font-semibold hover:bg-gray-50 transition text-sm">초기 리셋</button>
                        </div>
                        <p id="toneStatusText" data-tone-status class="text-xs text-gray-500 mt-2">말투 프로필: 아직 분석하지 않았습니다.</p>
                    </div>
                </section>
            </div>
        </div>
    </div>

    <!-- Main Content Area -->
    <main class="flex-1 flex overflow-hidden relative">

        <!-- Tab 1: Writer -->
        <div id="view-writer"
            class="w-full h-full flex flex-col lg:flex-row absolute inset-0 transition-opacity duration-300">
            <!-- Left Panel: Controls (Fixed width on Desktop) -->
            <div
                class="w-full lg:w-[400px] lg:flex-shrink-0 bg-white border-r border-gray-200 flex flex-col h-full shadow-[4px_0_24px_rgba(0,0,0,0.02)] z-10">
                <div id="writerControlsScroll" class="p-6 flex-1 overflow-y-auto custom-scrollbar">
                    <div class="mb-8">
                        <label class="block text-sm font-bold text-gray-700 mb-2 flex items-center gap-2">1. 주제 및 키워드
                            <span
                                class="text-xs font-normal text-pink-500 bg-pink-50 px-2 py-0.5 rounded-full">필수</span></label>
                        <textarea id="topicInput" rows="5"
                            class="w-full bg-gray-50 border border-gray-200 rounded-xl p-4 focus:ring-2 focus:ring-pink-500 focus:bg-white transition resize-none text-sm placeholder-gray-400 leading-relaxed shadow-sm"
                            placeholder="예: 파주 '카페 멜로우' 방문 후기.&#10;- 주차장 넓음, 2시간 무료&#10;- 소금빵(3,500원) 강추&#10;- 남편이랑 데이트"></textarea>
                    </div>
                    <div class="mb-8">
                        <label class="block text-sm font-bold text-gray-700 mb-2 flex items-center gap-2">1-1. 작성 보조 정보
                            <span
                                class="text-xs font-normal text-gray-400 bg-gray-100 px-2 py-0.5 rounded-full">선택</span></label>
                        <div class="grid grid-cols-1 gap-3">
                            <input type="text" id="mainKeywordInput" placeholder="우선 키워드 (쉼표로 구분) 예: 파주카페, 내돈내산, 데이트코스"
                                class="w-full bg-gray-50 border border-gray-200 rounded-xl p-3 focus:ring-2 focus:ring-pink-500 focus:bg-white transition text-sm placeholder-gray-400 shadow-sm">
                            <input type="text" id="targetReaderInput" placeholder="타깃 독자 예: 주말 데이트 찾는 30대 부부"
                                class="w-full bg-gray-50 border border-gray-200 rounded-xl p-3 focus:ring-2 focus:ring-pink-500 focus:bg-white transition text-sm placeholder-gray-400 shadow-sm">
                            <p class="text-[11px] text-gray-500 leading-relaxed">
                                팁: 입력한 정보는 AI가 "완성본 대필"이 아니라 작성 보조용 구조/제목/노출 제안에만 사용합니다.
                            </p>
                        </div>
                    </div>
                    <div class="mb-8">
                        <label class="block text-sm font-bold text-gray-700 mb-2 flex items-center gap-2">2. 사진 업로드
                            <span
                                class="text-xs font-normal text-gray-400 bg-gray-100 px-2 py-0.5 rounded-full">선택</span></label>
                        <div id="dropZone"
                            class="border-2 border-dashed border-gray-300 rounded-xl p-8 text-center hover:border-pink-400 hover:bg-pink-50 transition cursor-pointer group"
                            onclick="document.getElementById('imageInput').click()">
                            <input type="file" id="imageInput" multiple accept="image/*" class="hidden"
                                onchange="handleImageSelect(event)" onclick="this.value=''" autocomplete="off">
                            <div class="text-4xl mb-3 group-hover:scale-110 transition duration-300 transform">📸</div>
                            <p class="text-sm text-gray-600 font-medium">사진 드래그 또는 클릭</p>
                        </div>

                        <!-- Photo Guide Fixed Structure -->
                        <div
                            class="mt-3 bg-gray-50 border border-gray-200 rounded-lg p-3 text-xs text-gray-600 leading-relaxed">
                            <div class="flex justify-between items-center mb-2">
                                <p id="photoGuideStatus" class="font-semibold text-gray-700">선택 0장 · 권장 8~20장 · 최대 30장
                                </p>
                                <button onclick="clearAllImages()"
                                    class="text-gray-400 hover:text-red-500 underline text-[11px] whitespace-nowrap ml-2 px-2 py-1 flex-shrink-0">
                                    🗑️ 전체 삭제
                                </button>
                            </div>
                            <div class="block border-t border-gray-200 pt-2 border-dashed">
                                <p class="mb-1 font-medium text-gray-500">추천 구성:</p>
                                <ul class="list-disc pl-4 space-y-0.5">
                                    <li>대표컷 1~2장, 장소/외관 1~2장</li>
                                    <li>분위기/내부 2~4장, 핵심 경험컷 3~6장</li>
                                    <li>정보 증빙컷(가격표/영수증/안내문) 1~2장</li>
                                </ul>
                            </div>
                        </div>

                        <div id="imagePreview" class="grid grid-cols-3 gap-2 mt-4"></div>
                    </div>
                    <div class="mb-2 rounded-xl border border-gray-200 bg-white/70 p-3">
                        <p class="text-[11px] font-semibold text-gray-600 mb-2">권장 순서대로 진행하세요</p>
                        <div class="space-y-2">
                            <button onclick="generatePost()"
                                class="w-full bg-gradient-to-r from-pink-500 to-rose-500 hover:from-pink-600 hover:to-rose-600 text-white font-bold py-3.5 rounded-xl shadow-lg shadow-pink-200 transform active:scale-[0.98] transition-all flex justify-center items-center gap-2 group">
                                <span class="group-hover:animate-bounce">🧭</span><span>1. 초안 만들기</span>
                            </button>
                            <button onclick="fixSpelling()"
                                class="w-full bg-white border border-gray-300 text-gray-700 font-bold py-3 rounded-xl hover:bg-gray-50 flex justify-center items-center gap-2">
                                ✍️ 2. 문장 다듬기
                            </button>
                            <button onclick="runLocalSeoCheck()"
                                class="w-full bg-white border border-gray-300 text-gray-700 font-bold py-3 rounded-xl hover:bg-gray-50 flex justify-center items-center gap-2">
                                📌 3. 노출 가능성 점검
                            </button>
                            <button onclick="onExternalRiskButtonClick()"
                                class="w-full bg-white border border-gray-300 text-gray-700 font-bold py-3 rounded-xl hover:bg-gray-50 flex justify-center items-center gap-2">
                                <span id="externalRiskButtonLabel">🌤️ 4. 외부 환경 리스크 점검</span>
                            </button>
                            <button onclick="generatePublishPack()"
                                class="w-full bg-rose-50 border border-rose-200 text-rose-700 font-bold py-3 rounded-xl hover:bg-rose-100 flex justify-center items-center gap-2">
                                🏷️ 5. 발행 요소 생성
                            </button>
                        </div>
                        <div id="externalRiskPanel"
                            class="mt-3 hidden grid grid-cols-1 sm:grid-cols-2 gap-2 p-3 bg-gray-50 border border-gray-200 rounded-lg">
                            <div class="sm:col-span-2 flex items-start justify-between gap-2 mb-1">
                                <p class="text-[11px] text-gray-600 leading-relaxed break-keep pr-1">4번 점검 전용 입력입니다. 모르면 기본값(보통) 유지 후 실행하세요.</p>
                                <button type="button" onclick="hideExternalRiskPanel()"
                                    class="shrink-0 whitespace-nowrap px-1 py-0.5 text-[11px] text-gray-500 underline hover:text-gray-700">닫기</button>
                            </div>
                            <label class="text-[11px] text-gray-600">
                                경쟁도
                                <select id="riskCompetitionInput"
                                    class="mt-1 w-full border border-gray-300 rounded-md px-2 py-1.5 text-xs bg-white">
                                    <option value="25">낮음</option>
                                    <option value="55" selected>보통</option>
                                    <option value="85">높음</option>
                                </select>
                            </label>
                            <label class="text-[11px] text-gray-600">
                                시즌성
                                <select id="riskSeasonalityInput"
                                    class="mt-1 w-full border border-gray-300 rounded-md px-2 py-1.5 text-xs bg-white">
                                    <option value="25">성수기/적합</option>
                                    <option value="55" selected>보통</option>
                                    <option value="85">비수기/부적합</option>
                                </select>
                            </label>
                            <label class="text-[11px] text-gray-600">
                                주제 포화도
                                <select id="riskSaturationInput"
                                    class="mt-1 w-full border border-gray-300 rounded-md px-2 py-1.5 text-xs bg-white">
                                    <option value="25">낮음</option>
                                    <option value="55" selected>보통</option>
                                    <option value="85">높음</option>
                                </select>
                            </label>
                            <label class="text-[11px] text-gray-600">
                                발행 타이밍
                                <select id="riskTimingInput"
                                    class="mt-1 w-full border border-gray-300 rounded-md px-2 py-1.5 text-xs bg-white">
                                    <option value="25">좋음</option>
                                    <option value="55" selected>보통</option>
                                    <option value="80">아쉬움</option>
                                </select>
                            </label>
                            <label class="text-[11px] text-gray-600 sm:col-span-2">
                                최근 활동성
                                <select id="riskActivityInput"
                                    class="mt-1 w-full border border-gray-300 rounded-md px-2 py-1.5 text-xs bg-white">
                                    <option value="20">활발함</option>
                                    <option value="50" selected>보통</option>
                                    <option value="80">낮음</option>
                                </select>
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Central Area: Content Editor + Publishing Panel (Flex container) -->
            <div class="flex-1 flex flex-col lg:flex-row h-full overflow-hidden relative">

                <!-- Editor Section -->
                <div class="flex-1 flex flex-col h-full bg-gray-50 relative min-w-0">
                    <div id="loadingOverlay"
                        class="absolute inset-0 bg-white/90 backdrop-blur-sm z-30 flex flex-col items-center justify-center hidden">
                        <div class="loading-spinner mb-6"></div>
                        <h3 class="text-xl font-bold text-gray-800 animate-pulse">AI가 열심히 일하고 있어요!</h3>
                        <p class="text-sm text-gray-500 mt-2" id="loadingText">잠시만 기다려주세요...</p>
                    </div>

                    <!-- Editor Scroll Area -->
                    <div class="flex-1 overflow-y-auto p-4 md:p-8 custom-scrollbar">
                        <div id="outputContent"
                            class="prose max-w-3xl mx-auto bg-white p-8 md:p-12 rounded-2xl shadow-sm min-h-[800px] outline-none border border-gray-100 text-gray-800"
                            contenteditable="true">
                            <div
                                class="flex flex-col items-center justify-center h-full text-gray-300 select-none py-20">
                                <div class="text-6xl mb-6 opacity-50">✍️</div>
                                <h3 class="text-xl font-bold text-gray-400 mb-2">작성된 글이 없습니다</h3>
                                <p class="text-sm text-gray-400">주제와 사진을 넣고<br>버튼을 눌러보세요!</p>
                            </div>
                        </div>
                    </div>

                    <!-- Bottom Bar -->
                    <div
                        class="bg-white border-t border-gray-200 px-6 py-4 flex justify-between items-center shadow-[0_-4px_24px_rgba(0,0,0,0.02)] z-20">
                        <div class="flex flex-col gap-1">
                            <span class="text-xs font-medium text-gray-400 flex items-center gap-1"><span
                                    class="w-2 h-2 rounded-full bg-green-400"></span>Gemini Ready</span>
                            <span class="text-xs text-gray-500">
                                공백 포함 <span id="charCountWithSpace">0</span>자 / 제외 <span
                                    id="charCountWithoutSpace">0</span>자
                            </span>
                            <div class="flex gap-2">
                                <span id="seoScoreBadge" class="text-[11px] text-gray-400">3단계 점검 전</span>
                                <span id="externalRiskBadge" class="text-[11px] text-gray-400">4단계 점검 전</span>
                            </div>
                        </div>
                        <div class="flex gap-3">
                            <button onclick="downloadAsFile()"
                                class="text-sm bg-white border border-gray-300 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-50 transition font-medium">💾
                                저장</button>
                            <button onclick="copyToClipboard()"
                                class="text-sm bg-gray-900 text-white px-5 py-2 rounded-lg hover:bg-black transition font-medium shadow-md">📋
                                전체 복사</button>
                        </div>
                    </div>
                </div>

                <!-- Publishing Panel: Right Sidebar (Desktop) / Bottom Collapsible (Mobile) -->
                <div id="publishPanel"
                    class="border-t lg:border-t-0 lg:border-l border-gray-200 bg-white lg:w-[420px] xl:w-[520px] flex-shrink-0 flex flex-col transition-all duration-300 z-20 shadow-[-4px_0_24px_rgba(0,0,0,0.02)]">

                    <!-- Panel Header -->
                    <div class="px-5 py-4 border-b border-gray-100 flex items-center justify-between bg-gray-50 lg:bg-white">
                        <div class="flex items-center gap-2">
                            <h4 class="font-bold text-gray-800 text-sm">발행 요소 (제목/태그)</h4>
                            <span id="assistStatus" class="text-[11px] text-gray-500">대기 중</span>
                        </div>
                        <!-- Toggle Button (Mobile Only) -->
                        <button id="publishPanelToggleBtn" onclick="togglePublishPanelMobile()" aria-expanded="false"
                            class="lg:hidden text-gray-400 hover:text-gray-600 transition">
                            🔼
                        </button>
                    </div>

                    <!-- Panel Content -->
                    <div id="publishPanelContent"
                        class="flex-1 custom-scrollbar p-0">
                        <div id="assistContent" class="prose prose-sm max-w-none px-5 py-4 text-sm text-gray-600">
                            <p>1~3단계 점검 후 4번 버튼으로 외부 리스크를 점검하고, 마지막에 <strong>5. 발행 요소 생성</strong>을 실행하세요.</p>
                            <div class="mt-4 p-3 bg-blue-50 text-blue-800 rounded-lg text-xs leading-relaxed">
                                💡 <strong>팁:</strong><br>
                                PC 등 넓은 화면에서는 이 패널이 우측에 고정되어, 글을 쓰면서 동시에 발행 정보를 참고하기 편합니다.
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <!-- Tab 2: Manager -->
        <div id="view-manager"
            class="w-full h-full flex flex-col absolute inset-0 bg-gray-50 hidden opacity-0 transition-opacity duration-300 overflow-y-auto custom-scrollbar">
            <div class="max-w-5xl mx-auto w-full p-8">

                <!-- Section 1: My Blog Dashboard -->
                <div class="hidden bg-white rounded-2xl shadow-sm border border-gray-200 p-8 mb-8">
                    <h2 class="text-xl font-bold text-gray-800 mb-6 flex items-center gap-2">
                        📡 내 블로그 관제탑
                    </h2>
                    <div class="flex gap-4 mb-6">
                        <input type="text" id="legacyBlogIdInput" placeholder="네이버 아이디 또는 블로그 주소 (https://blog.naver.com/...)"
                            class="flex-1 border border-gray-300 rounded-xl p-4 focus:ring-2 focus:ring-pink-500 outline-none text-lg">
                        <button onclick="saveBlogId()"
                            class="bg-gray-800 text-white px-8 rounded-xl font-bold hover:bg-black transition">저장</button>
                        <button onclick="refreshToneProfile()"
                            class="bg-pink-600 text-white px-6 rounded-xl font-bold hover:bg-pink-700 transition whitespace-nowrap">말투
                            분석</button>
                    </div>
                    <p id="legacyToneStatusText" class="text-xs text-gray-500 mb-6">말투 프로필: 아직 분석하지 않았습니다.</p>

                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div onclick="openAnalysis('blackkiwi')"
                            class="cursor-pointer bg-blue-50 border border-blue-100 p-6 rounded-xl hover:shadow-md transition group">
                            <div class="text-2xl mb-2">🥝</div>
                            <h3 class="font-bold text-blue-900 mb-1">블랙키위 분석</h3>
                            <p class="text-sm text-blue-600">키워드 포화도 & 등급 확인</p>
                        </div>
                        <div onclick="openAnalysis('blogchart')"
                            class="cursor-pointer bg-green-50 border border-green-100 p-6 rounded-xl hover:shadow-md transition group">
                            <div class="text-2xl mb-2">📊</div>
                            <h3 class="font-bold text-green-900 mb-1">블로그 차트</h3>
                            <p class="text-sm text-green-600">내 블로그 전체 순위 확인</p>
                        </div>
                        <div onclick="openAnalysis('naverstats')"
                            class="cursor-pointer bg-gray-50 border border-gray-200 p-6 rounded-xl hover:shadow-md transition group">
                            <div class="text-2xl mb-2">📈</div>
                            <h3 class="font-bold text-gray-900 mb-1">네이버 통계</h3>
                            <p class="text-sm text-gray-600">공식 방문자 통계 바로가기</p>
                        </div>
                    </div>
                </div>

                <!-- Section 1: Quick Polish -->
                <div class="bg-white rounded-2xl shadow-sm border border-gray-200 p-8 mb-8">
                    <h2 class="text-xl font-bold text-gray-800 mb-2 flex items-center gap-2">
                        ✍️ 빠른 맞춤법/문장 교정
                    </h2>
                    <p class="text-sm text-gray-500 mb-6">완성 대필이 아니라, 작성자가 최종 수정하기 쉽게 문장 품질만 빠르게 정리합니다.</p>

                    <div class="grid grid-cols-1 xl:grid-cols-2 gap-6 xl:items-stretch">
                        <div class="bg-gray-50 rounded-xl border border-gray-200 p-5 flex flex-col min-h-[420px]">
                            <label class="block text-sm font-bold text-gray-700 mb-2">교정할 문장/문단</label>
                            <textarea id="managerQuickInput"
                                class="w-full flex-1 min-h-[260px] bg-white border border-gray-200 rounded-xl p-4 resize-none focus:ring-2 focus:ring-pink-500 outline-none text-sm text-gray-700"
                                placeholder="교정할 문장을 붙여넣으세요.&#10;완전 재작성보다, 맞춤법/문장 흐름 정리에 집중합니다."></textarea>
                            <div class="flex flex-wrap gap-2 mt-3">
                                <button onclick="fillManagerQuickInputFromWriter()"
                                    class="text-xs bg-white border border-gray-300 text-gray-700 px-3 py-2 rounded-lg hover:bg-gray-50 transition">글쓰기 본문 불러오기</button>
                                <button onclick="clearManagerQuickInput()"
                                    class="text-xs bg-white border border-gray-300 text-gray-700 px-3 py-2 rounded-lg hover:bg-gray-50 transition">입력 비우기</button>
                            </div>
                        </div>

                        <div class="bg-gray-50 rounded-xl border border-gray-200 p-5 flex flex-col min-h-[420px]">
                            <div class="flex flex-wrap gap-2 mb-3">
                                <button onclick="runManagerSpellingCheck()"
                                    class="bg-gray-900 text-white text-xs px-3 py-2 rounded-lg hover:bg-black transition font-semibold">맞춤법 검사</button>
                                <button onclick="runManagerSentencePolish()"
                                    class="bg-pink-600 text-white text-xs px-3 py-2 rounded-lg hover:bg-pink-700 transition font-semibold">문장 다듬기</button>
                                <button onclick="copyManagerQuickResult()"
                                    class="bg-white border border-gray-300 text-gray-700 text-xs px-3 py-2 rounded-lg hover:bg-gray-100 transition">결과 복사</button>
                            </div>
                            <div id="managerQuickResult"
                                class="prose prose-sm max-w-none text-sm text-gray-700 flex-1 min-h-0 overflow-y-auto custom-scrollbar">
                                <p class="text-gray-400 text-center mt-10">맞춤법 검사나 문장 다듬기 결과가 여기에 표시됩니다.</p>
                            </div>
                        </div>
                    </div>

                    <div class="mt-6 border-t border-dashed border-gray-200 pt-5">
                        <p data-tone-status class="text-xs text-gray-500">말투 프로필: 아직 분석하지 않았습니다.</p>
                    </div>
                </div>

                <!-- Section 2: Post Audit -->
                <div class="bg-white rounded-2xl shadow-sm border border-gray-200 p-8">
                    <h2 class="text-xl font-bold text-gray-800 mb-2 flex items-center gap-2">
                        🩺 포스팅 정밀 진단
                    </h2>
                    <p class="text-sm text-gray-500 mb-6">완성 대필이 아니라, 강점/리스크/우선 수정 액션 중심으로 점검해 최종 작성 판단을 돕습니다.</p>

                    <div class="grid grid-cols-1 xl:grid-cols-2 gap-6 min-h-[520px]">
                        <div class="flex flex-col gap-3">
                            <div>
                                <label class="block text-sm font-bold text-gray-700 mb-1">포스팅 주소 (URL)</label>
                                <div class="flex gap-2">
                                    <input type="text" id="auditUrlInput"
                                        placeholder="예: https://blog.naver.com/hongttoyeon/223..."
                                        class="flex-1 border border-gray-300 rounded-lg p-3 focus:ring-2 focus:ring-pink-500 outline-none text-sm">
                                    <button onclick="fetchAndAuditPost()"
                                        class="bg-gray-800 text-white px-4 rounded-lg font-bold hover:bg-black transition whitespace-nowrap">가져오기</button>
                                </div>
                                <p class="text-xs text-gray-500 mt-1">💡 복사 방지된 글도 주소만 넣으면 내용을 가져옵니다.</p>
                            </div>

                            <div class="flex-1 flex flex-col">
                                <div class="flex items-center justify-between gap-2 mb-1">
                                    <label class="block text-sm font-bold text-gray-700 mb-0">진단할 본문</label>
                                    <button type="button" onclick="fillAuditInputFromWriterDraft()"
                                        class="text-[11px] bg-white border border-gray-300 text-gray-600 px-2.5 py-1 rounded-md hover:bg-gray-50 transition whitespace-nowrap">글쓰기 본문 불러오기</button>
                                </div>
                                <textarea id="auditInput"
                                    class="w-full flex-1 min-h-[240px] bg-gray-50 border border-gray-200 rounded-xl p-4 resize-none focus:ring-2 focus:ring-pink-500 outline-none text-sm text-gray-600"
                                    placeholder="URL을 입력하고 '가져오기'를 누르세요.&#10;또는 여기에 직접 내용을 붙여넣으셔도 됩니다."></textarea>
                            </div>

                            <button onclick="auditPost()"
                                class="w-full bg-pink-600 hover:bg-pink-700 text-white font-bold py-3 rounded-xl shadow-md transition">
                                🚀 AI 정밀진단 실행
                            </button>
                        </div>
                        <div class="bg-gray-50 rounded-xl border border-gray-200 p-6 overflow-y-auto min-h-[320px]">
                            <div id="auditResult" class="prose text-sm">
                                <p class="text-gray-400 text-center mt-20">진단 결과가 여기에 표시됩니다.</p>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>

    </main>

    <script>
        // --- Configuration ---
        const DEFAULT_GEMINI_MODEL = "gemini-2.0-flash";
        const GEMINI_MODEL_PREFERENCES = [
            "gemini-2.5-flash",
            "gemini-2.0-flash",
            "gemini-1.5-flash",
            "gemini-1.5-pro",
            "gemini-1.0-pro"
        ];
        const TONE_SAMPLE_COUNT = 12;
        const TONE_CACHE_TTL_MS = 1000 * 60 * 60 * 24 * 3; // 3 days
        const TONE_CACHE_PREFIX = "naver_tone_profile_";
        const API_KEY_LIST_STORAGE_KEY = "gemini_api_keys_v1";
        const API_KEY_ACTIVE_ID_STORAGE_KEY = "gemini_api_key_active_id_v1";
        const PHOTO_RECOMMENDED_MIN = 8;
        const PHOTO_RECOMMENDED_MAX = 20;
        const PHOTO_HARD_MAX = 30;
        const MAX_SINGLE_IMAGE_MB = 20;
        const MAX_TOTAL_IMAGE_PAYLOAD_MB = 18;
        const IMAGE_READ_TIMEOUT_MS = 90000;
        let userImages = [];
        let uploadedImageItems = [];
        let isUploadingFiles = false;
        let currentTab = 'writer';
        let activeToneProfile = null;
        let isExternalRiskPanelOpen = false;

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            checkApiKey();
            setupDragAndDrop();
            loadBlogId();
            updateToneStatusFromCache();
            setupCharCounter();
            updateCharCount();
            updatePhotoGuideStatus(0);
            updateSeoScoreBadge(null);
            updateExternalRiskBadge(null);
            resetAssistPanel();
            setExternalRiskPanel(false);
            setPublishPanelMobileOpen(false);

            // Defensive clear to prevent ghost images from browser restoration
            const imgInput = document.getElementById('imageInput');
            if (imgInput) imgInput.value = '';
        });

        window.addEventListener('pageshow', () => {
            // Prevent stale file/input state when page is restored from bfcache.
            resetUploadState();
            setExternalRiskPanel(false);
            setPublishPanelMobileOpen(false);
        });

        // --- Tab Logic ---
        function switchTab(tabName) {
            currentTab = tabName;
            const writerView = document.getElementById('view-writer');
            const managerView = document.getElementById('view-manager');
            const writerTab = document.getElementById('tab-writer');
            const managerTab = document.getElementById('tab-manager');

            if (tabName === 'writer') {
                writerView.classList.remove('hidden');
                setTimeout(() => writerView.classList.remove('opacity-0'), 10);
                managerView.classList.add('opacity-0');
                setTimeout(() => managerView.classList.add('hidden'), 300);

                writerTab.className = 'pb-3 px-1 transition-all tab-active';
                managerTab.className = 'pb-3 px-1 transition-all tab-inactive';
            } else {
                managerView.classList.remove('hidden');
                setTimeout(() => managerView.classList.remove('opacity-0'), 10);
                writerView.classList.add('opacity-0');
                setTimeout(() => writerView.classList.add('hidden'), 300);

                writerTab.className = 'pb-3 px-1 transition-all tab-inactive';
                managerTab.className = 'pb-3 px-1 transition-all tab-active';
            }
        }

        // --- Drag & Drop ---
        function setupDragAndDrop() {
            const dropZone = document.getElementById('dropZone');
            if (!dropZone) return;

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => dropZone.addEventListener(e, preventDefaults, false));
            function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
            ['dragenter', 'dragover'].forEach(e => dropZone.addEventListener(e, () => dropZone.classList.add('border-pink-500', 'bg-pink-50', 'scale-[1.02]'), false));
            ['dragleave', 'drop'].forEach(e => dropZone.addEventListener(e, () => dropZone.classList.remove('border-pink-500', 'bg-pink-50', 'scale-[1.02]'), false));
            dropZone.addEventListener('drop', handleDrop, false);
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;

            if (dt && dt.files && dt.files.length > 0) {
                handleFiles(dt.files);
                return;
            }

            if (dt && dt.items && dt.items.length > 0) {
                const fallbackFiles = Array.from(dt.items)
                    .filter(item => item.kind === 'file')
                    .map(item => item.getAsFile())
                    .filter(Boolean);
                handleFiles(fallbackFiles);
                return;
            }

            handleFiles([]);
        }

        function handleImageSelect(e) {
            const files = e?.target?.files || [];
            handleFiles(files);
            if (e?.target) e.target.value = '';
        }

        function clearAllImages() {
            if (uploadedImageItems.length === 0) return;
            if (!confirm('업로드된 모든 사진을 삭제하시겠습니까?')) return;
            resetUploadState();
        }

        function isImageLikeFile(file) {
            if (!file) return false;
            if (file.type && file.type.startsWith('image/')) return true;
            return /\.(png|jpe?g|gif|webp|bmp|heic|heif|avif|jfif|tiff?|svg)$/i.test(file.name || '');
        }

        function isHeicLikeFile(file) {
            if (!file) return false;
            const type = (file.type || '').toLowerCase();
            if (type === 'image/heic' || type === 'image/heif' || type === 'image/heic-sequence' || type === 'image/heif-sequence') {
                return true;
            }
            return /\.(heic|heif)$/i.test(file.name || '');
        }

        function getMimeTypeFromFile(file, dataUrl) {
            if (file && file.type && file.type.startsWith('image/')) return file.type;

            const ext = ((file && file.name) || '').toLowerCase().split('.').pop();
            const extMap = {
                jpg: 'image/jpeg',
                jpeg: 'image/jpeg',
                jfif: 'image/jpeg',
                png: 'image/png',
                webp: 'image/webp',
                gif: 'image/gif',
                bmp: 'image/bmp',
                tif: 'image/tiff',
                tiff: 'image/tiff',
                svg: 'image/svg+xml',
                avif: 'image/avif',
                heic: 'image/jpeg',
                heif: 'image/jpeg'
            };
            if (extMap[ext]) return extMap[ext];

            const match = /^data:(image\/[a-z0-9.+-]+);base64,/i.exec(dataUrl || '');
            if (match) return match[1];
            return 'image/jpeg';
        }

        function extractBlobFromHeicResult(converted) {
            if (!converted) return null;
            if (converted instanceof Blob) return converted;
            if (Array.isArray(converted)) {
                for (const item of converted) {
                    if (item instanceof Blob) return item;
                }
            }
            return null;
        }

        const HEIC_CONVERT_TIMEOUT_MS = 15000;

        async function convertHeicFile(file) {
            if (!isHeicLikeFile(file)) return file;
            if (typeof heic2any !== 'function') {
                throw new Error('HEIC 변환 라이브러리 로드 실패');
            }

            // Lowered quality slightly for better success rate
            const attempts = [
                { toType: 'image/jpeg', quality: 0.70, ext: 'jpg' },
                { toType: 'image/jpeg', quality: 0.50, ext: 'jpg' },
                { toType: 'image/png', quality: 0.8, ext: 'png' }
            ];

            let lastError = null;

            const convertWithTimeout = (options) => {
                return new Promise((resolve, reject) => {
                    const timer = setTimeout(() => reject(new Error('HEIC 변환 시간 초과')), HEIC_CONVERT_TIMEOUT_MS);
                    heic2any(options)
                        .then(res => { clearTimeout(timer); resolve(res); })
                        .catch(err => { clearTimeout(timer); reject(err); });
                });
            };

            for (const attempt of attempts) {
                try {
                    const converted = await convertWithTimeout({
                        blob: file,
                        toType: attempt.toType,
                        quality: attempt.quality
                    });

                    const blob = extractBlobFromHeicResult(converted);
                    if (!blob || blob.size === 0) {
                        throw new Error('변환 결과가 비어 있습니다');
                    }

                    const outType = blob.type && blob.type.startsWith('image/')
                        ? blob.type
                        : attempt.toType;
                    const outName = (file.name || 'image').replace(/\.(heic|heif)$/i, '.' + attempt.ext);

                    return new File([blob], outName, {
                        type: outType,
                        lastModified: file.lastModified || Date.now()
                    });
                } catch (err) {
                    lastError = err;
                    console.warn(`HEIC conversion attempt failed (${attempt.toType}, q=${attempt.quality})`, err);
                }
            }

            throw lastError || new Error('HEIC 변환 실패 (모든 시도 에러)');
        }

        function readFileAsDataUrl(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                const timer = setTimeout(() => {
                    try { reader.abort(); } catch (e) { /* no-op */ }
                    reject(new Error('파일 읽기 시간 초과'));
                }, IMAGE_READ_TIMEOUT_MS);

                reader.onload = (e) => {
                    clearTimeout(timer);
                    resolve((e?.target?.result || '').toString());
                };

                reader.onerror = () => {
                    clearTimeout(timer);
                    reject(new Error('파일 읽기 실패'));
                };

                reader.onabort = () => {
                    clearTimeout(timer);
                    reject(new Error('파일 읽기 중단'));
                };

                try {
                    reader.readAsDataURL(file);
                } catch (err) {
                    clearTimeout(timer);
                    reject(err);
                }
            });
        }

        async function readFileAsDataUrlSafe(file) {
            try {
                return await readFileAsDataUrl(file);
            } catch (firstErr) {
                try {
                    const buffer = await file.arrayBuffer();
                    const bytes = new Uint8Array(buffer);
                    const chunkSize = 0x8000;
                    let binary = '';

                    for (let i = 0; i < bytes.length; i += chunkSize) {
                        const chunk = bytes.subarray(i, i + chunkSize);
                        binary += String.fromCharCode(...chunk);
                    }

                    const mime = (file.type && file.type.startsWith('image/')) ? file.type : 'image/jpeg';
                    return `data:${mime};base64,${btoa(binary)}`;
                } catch (fallbackErr) {
                    console.error('ArrayBuffer fallback failed', fallbackErr, firstErr);
                    throw firstErr;
                }
            }
        }

        function resetUploadState() {
            userImages = [];
            uploadedImageItems = [];
            isUploadingFiles = false;

            const container = document.getElementById('imagePreview');
            if (container) container.innerHTML = '';

            const imageInput = document.getElementById('imageInput');
            if (imageInput) imageInput.value = '';

            updatePhotoGuideStatus(0);
        }

        function syncUserImagesFromUploadedItems() {
            userImages = uploadedImageItems.map(item => ({
                inlineData: {
                    data: item.inlineData.data,
                    mimeType: item.inlineData.mimeType
                }
            }));
            updatePhotoGuideStatus(userImages.length);
        }

        function renderImagePreview() {
            const container = document.getElementById('imagePreview');
            if (!container) return;

            container.innerHTML = uploadedImageItems.map((item, idx) => `
                <div class="relative aspect-square rounded-lg overflow-hidden border border-gray-200 animate-fade-in">
                    <img src="${item.previewUrl}" class="w-full h-full object-cover">
                    <span class="absolute top-1 right-1 bg-black/50 text-white text-[10px] px-1.5 rounded-full">${idx + 1}</span>
                    <button type="button"
                        class="absolute top-1 left-1 w-5 h-5 rounded-full bg-white/90 text-gray-800 text-[11px] font-bold hover:bg-white"
                        onclick="removeImageAt(${idx})"
                        aria-label="remove image">X</button>
                </div>
            `).join('');
        }

        function removeImageAt(index) {
            if (index < 0 || index >= uploadedImageItems.length) return;
            uploadedImageItems.splice(index, 1);
            syncUserImagesFromUploadedItems();
            renderImagePreview();
        }

        async function handleFiles(files) {
            const fileArray = Array.from(files || []).filter(Boolean);
            if (fileArray.length === 0) return;

            if (isUploadingFiles) {
                alert('이전 사진 업로드를 처리 중입니다. 잠시 후 다시 시도해주세요.');
                return;
            }

            const currentCount = uploadedImageItems.length;
            if (currentCount >= PHOTO_HARD_MAX) {
                alert('이미 최대 ' + PHOTO_HARD_MAX + '장이 업로드되어 있습니다. 필요 없는 사진을 X로 삭제한 뒤 추가해주세요.');
                return;
            }

            isUploadingFiles = true;
            showLoading(true, "사진을 처리하고 있습니다...");

            try {
                const imageCandidates = fileArray.filter(isImageLikeFile);
                if (imageCandidates.length === 0) {
                    alert('이미지 파일만 업로드할 수 있습니다.');
                    return;
                }

                const remainingSlots = PHOTO_HARD_MAX - uploadedImageItems.length;
                const selectedFiles = imageCandidates.slice(0, remainingSlots);
                const maxBytes = MAX_SINGLE_IMAGE_MB * 1024 * 1024;
                let skippedTooLarge = 0;
                let skippedReadError = 0;
                let skippedHeicConvert = 0;
                let skippedPayloadLimit = 0;
                let addedCount = 0;
                let readFailMaxMb = 0;
                let convertFailMaxMb = 0;

                if (imageCandidates.length > remainingSlots) {
                    alert('최대 ' + PHOTO_HARD_MAX + '장까지 가능합니다. 이번에는 ' + selectedFiles.length + '장만 추가됩니다.');
                }

                for (let i = 0; i < selectedFiles.length; i++) {
                    let file = selectedFiles[i];
                    if (!file) continue;

                    if (file.size > maxBytes) {
                        skippedTooLarge += 1;
                        continue;
                    }

                    // Handle HEIC/HEIF
                    if (isHeicLikeFile(file)) {
                        try {
                            file = await convertHeicFile(file);
                        } catch (e) {
                            console.error("HEIC conversion failed", e);
                            skippedHeicConvert += 1;
                            convertFailMaxMb = Math.max(convertFailMaxMb, Number(file.size || 0) / (1024 * 1024));
                            continue;
                        }
                    }

                    if (!isImageLikeFile(file)) continue;

                    if (file.size > maxBytes) {
                        skippedTooLarge += 1;
                        continue;
                    }

                    try {
                        const dataUrl = await readFileAsDataUrlSafe(file);
                        const base64 = (dataUrl || '').toString().split(',')[1];
                        if (!base64) {
                            skippedReadError += 1;
                            continue;
                        }

                        const nextSizeBytes = Math.floor(base64.length * 0.75);
                        const totalPayloadAfterAdd = getCurrentImagePayloadBytes() + nextSizeBytes;
                        const payloadLimitBytes = MAX_TOTAL_IMAGE_PAYLOAD_MB * 1024 * 1024;
                        if (totalPayloadAfterAdd > payloadLimitBytes) {
                            skippedPayloadLimit += 1;
                            continue;
                        }

                        uploadedImageItems.push({
                            inlineData: {
                                data: base64,
                                mimeType: getMimeTypeFromFile(file, dataUrl)
                            },
                            previewUrl: dataUrl
                        });
                        addedCount += 1;
                    } catch (e) {
                        console.error('Image read failed', e);
                        skippedReadError += 1;
                        readFailMaxMb = Math.max(readFailMaxMb, Number(file.size || 0) / (1024 * 1024));
                    }
                }

                syncUserImagesFromUploadedItems();
                renderImagePreview();

                if (skippedTooLarge > 0 || skippedHeicConvert > 0 || skippedReadError > 0 || skippedPayloadLimit > 0) {
                    let msg = '';
                    if (skippedTooLarge > 0) msg += '용량 초과(' + MAX_SINGLE_IMAGE_MB + 'MB) ' + skippedTooLarge + '장';
                    if (skippedHeicConvert > 0) {
                        msg += (msg ? ', ' : '') + 'HEIC 변환 실패 ' + skippedHeicConvert + '장';
                        if (convertFailMaxMb > 0) msg += ' (최대 약 ' + convertFailMaxMb.toFixed(1) + 'MB)';
                    }
                    if (skippedReadError > 0) {
                        msg += (msg ? ', ' : '') + '읽기 실패 ' + skippedReadError + '장';
                        if (readFailMaxMb > 0) msg += ' (최대 약 ' + readFailMaxMb.toFixed(1) + 'MB)';
                    }
                    if (skippedPayloadLimit > 0) {
                        msg += (msg ? ', ' : '') + '전송 한도 초과 ' + skippedPayloadLimit + '장';
                        msg += ` (총 이미지 데이터 ${MAX_TOTAL_IMAGE_PAYLOAD_MB}MB 제한)`;
                    }
                    if (addedCount === 0) {
                        alert('업로드된 사진이 없습니다. ' + msg);
                    } else {
                        alert('일부 사진이 제외되었습니다: ' + msg);
                    }
                }
            } catch (error) {
                alert('사진 처리 중 오류가 발생했습니다: ' + error.message);
            } finally {
                isUploadingFiles = false;
                showLoading(false);
                const imageInput = document.getElementById('imageInput');
                if (imageInput) imageInput.value = '';
            }
        }

        function updatePhotoGuideStatus(count) {
            const statusEl = document.getElementById('photoGuideStatus');
            if (!statusEl) return;

            let msg = '선택 ' + count + '장 · 권장 ' + PHOTO_RECOMMENDED_MIN + '~' + PHOTO_RECOMMENDED_MAX + '장 · 최대 ' + PHOTO_HARD_MAX + '장';
            let cls = 'font-semibold text-gray-700 mb-2';

            if (count === 0) {
                msg = '선택 0장 · 권장 ' + PHOTO_RECOMMENDED_MIN + '~' + PHOTO_RECOMMENDED_MAX + '장 · 최대 ' + PHOTO_HARD_MAX + '장';
            } else if (count < PHOTO_RECOMMENDED_MIN) {
                msg += ' (조금 더 올리면 정확도가 좋아져요)';
                cls = 'font-semibold text-amber-600 mb-2';
            } else if (count <= PHOTO_RECOMMENDED_MAX) {
                msg += ' (좋은 구성입니다)';
                cls = 'font-semibold text-emerald-600 mb-2';
            } else if (count <= PHOTO_HARD_MAX) {
                msg += ' (많은 편입니다. 핵심 사진 위주로 정리해보세요)';
                cls = 'font-semibold text-orange-600 mb-2';
            } else {
                msg += ' (처음 ' + PHOTO_HARD_MAX + '장만 사용됩니다)';
                cls = 'font-semibold text-red-600 mb-2';
            }

            statusEl.className = cls;
            statusEl.textContent = msg;
        }

        function getCurrentImagePayloadBytes() {
            return uploadedImageItems.reduce((sum, item) => {
                const base64 = item?.inlineData?.data || '';
                return sum + Math.floor(base64.length * 0.75);
            }, 0);
        }

        function escapeRegExp(value) {
            return (value || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function parseKeywordList(raw) {
            return (raw || '')
                .split(/[,/\n]/)
                .map(v => v.trim())
                .filter(Boolean)
                .filter((v, idx, arr) => arr.indexOf(v) === idx)
                .slice(0, 12);
        }

        function extractKeywordCandidatesFromText(text, limit = 8) {
            const stopWords = new Set([
                '오늘', '이번', '정말', '진짜', '후기', '추천', '방문', '리뷰', '사용', '사진', '작성', '내용', '정리',
                '그리고', '그래서', '그냥', '저는', '저희', '우리', '합니다', '있어요', '입니다'
            ]);
            const cleaned = (text || '').replace(/[^\uAC00-\uD7A3a-zA-Z0-9\s]/g, ' ');
            const tokens = cleaned.split(/\s+/).filter(Boolean);
            const counts = new Map();

            for (const token of tokens) {
                if (token.length < 2) continue;
                if (/^\d+$/.test(token)) continue;
                if (stopWords.has(token)) continue;
                counts.set(token, (counts.get(token) || 0) + 1);
            }

            return [...counts.entries()]
                .sort((a, b) => b[1] - a[1])
                .slice(0, limit)
                .map(([word]) => word);
        }

        function getWriterContext() {
            const topic = (document.getElementById('topicInput')?.value || '').trim();
            const targetReaderRaw = (document.getElementById('targetReaderInput')?.value || '').trim();
            const manualKeywords = parseKeywordList(document.getElementById('mainKeywordInput')?.value || '');
            const fallbackKeywords = extractKeywordCandidatesFromText(topic, 8);

            return {
                topic,
                targetReader: targetReaderRaw || '일반 독자',
                manualKeywords,
                effectiveKeywords: manualKeywords.length ? manualKeywords : fallbackKeywords
            };
        }

        function setAssistStatus(message, isError = false) {
            const el = document.getElementById('assistStatus');
            if (!el) return;
            el.textContent = message;
            el.className = `text-[11px] ${isError ? 'text-red-500' : 'text-gray-500'}`;
        }

        function setAssistContentMarkdown(markdownText, statusMessage, isError = false) {
            const el = document.getElementById('assistContent');
            if (!el) return;
            el.innerHTML = marked.parse(markdownText || '');
            setAssistStatus(statusMessage, isError);
        }

        function resetAssistPanel() {
            const el = document.getElementById('assistContent');
            if (!el) return;
            el.innerHTML = '<p>1~3단계 점검 후 4번 버튼으로 외부 리스크를 점검하고, 마지막에 <strong>5. 발행 요소 생성</strong>을 실행하세요.</p>';
            setAssistStatus('아직 생성 전');
        }

        function updateSeoScoreBadge(score) {
            const badge = document.getElementById('seoScoreBadge');
            if (!badge) return;

            if (score === null || score === undefined || Number.isNaN(score)) {
                badge.textContent = '3단계 점검 전';
                badge.className = 'text-[11px] text-gray-400';
                return;
            }

            const safeScore = Math.max(0, Math.min(100, Math.round(score)));
            if (safeScore >= 85) {
                badge.textContent = `로컬 노출 점수 ${safeScore}점 (양호)`;
                badge.className = 'text-[11px] text-emerald-600';
            } else if (safeScore >= 70) {
                badge.textContent = `로컬 노출 점수 ${safeScore}점 (보완 권장)`;
                badge.className = 'text-[11px] text-amber-600';
            } else {
                badge.textContent = `로컬 노출 점수 ${safeScore}점 (개선 필요)`;
                badge.className = 'text-[11px] text-rose-600';
            }
        }

        function updateExternalRiskBadge(score) {
            const badge = document.getElementById('externalRiskBadge');
            if (!badge) return;

            if (score === null || score === undefined || Number.isNaN(score)) {
                badge.textContent = '4단계 점검 전';
                badge.className = 'text-[11px] text-gray-400';
                return;
            }

            const safeScore = Math.max(0, Math.min(100, Math.round(score)));
            if (safeScore <= 39) {
                badge.textContent = `외부 리스크 ${safeScore}점 (낮음)`;
                badge.className = 'text-[11px] text-emerald-600';
            } else if (safeScore <= 69) {
                badge.textContent = `외부 리스크 ${safeScore}점 (보통)`;
                badge.className = 'text-[11px] text-amber-600';
            } else {
                badge.textContent = `외부 리스크 ${safeScore}점 (높음)`;
                badge.className = 'text-[11px] text-rose-600';
            }
        }

        function scrollToExternalRiskPanel() {
            const panel = document.getElementById('externalRiskPanel');
            if (!panel || panel.classList.contains('hidden')) return;

            const scrollArea = document.getElementById('writerControlsScroll');
            const scrollAction = () => {
                if (scrollArea) {
                    const panelTop = panel.offsetTop;
                    const targetTop = Math.max(panelTop - 12, 0);
                    scrollArea.scrollTo({ top: targetTop, behavior: 'smooth' });
                } else {
                    panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }

                panel.classList.add('ring-2', 'ring-pink-200');
                window.setTimeout(() => {
                    panel.classList.remove('ring-2', 'ring-pink-200');
                }, 900);
            };

            requestAnimationFrame(() => requestAnimationFrame(scrollAction));
        }

        function setExternalRiskPanel(open) {
            const panel = document.getElementById('externalRiskPanel');
            const label = document.getElementById('externalRiskButtonLabel');
            if (!panel || !label) return;

            isExternalRiskPanelOpen = Boolean(open);

            if (isExternalRiskPanelOpen) {
                panel.classList.remove('hidden');
                scrollToExternalRiskPanel();
                label.textContent = '🌤️ 4. 외부 환경 리스크 점검 실행';
            } else {
                panel.classList.add('hidden');
                panel.classList.remove('ring-2', 'ring-pink-200');
                label.textContent = '🌤️ 4. 외부 환경 리스크 점검';
            }
        }

        function hideExternalRiskPanel() {
            setExternalRiskPanel(false);
            setAssistStatus('4단계 옵션 닫힘');
        }

        function onExternalRiskButtonClick() {
            if (!isExternalRiskPanelOpen) {
                setExternalRiskPanel(true);
                setAssistStatus('4단계 옵션 열림: 값 확인 후 4번 버튼을 다시 누르세요.');
                return;
            }
            runExternalRiskCheck();
        }

        function runLocalSeoCheck() {
            const draft = getOutputTextForCount().trim();
            const { topic, effectiveKeywords, targetReader } = getWriterContext();

            if (!topic && draft.length < 80) {
                alert('주제 또는 초안이 충분하지 않습니다. 먼저 초안을 만들거나 내용을 입력해주세요.');
                return;
            }

            let score = 100;
            const actionItems = [];

            const bodyLength = draft.length;
            const paragraphCount = draft ? draft.split(/\n{2,}/).map(v => v.trim()).filter(Boolean).length : 0;
            const topicSignals = new Set(
                [
                    ...effectiveKeywords.map(v => v.toLowerCase()),
                    ...extractKeywordCandidatesFromText(topic, 20).map(v => v.toLowerCase())
                ].filter(Boolean)
            );
            const keywordStats = effectiveKeywords.map(keyword => {
                const matches = draft.match(new RegExp(escapeRegExp(keyword), 'gi'));
                return { keyword, count: matches ? matches.length : 0 };
            });
            const usedKeywordCount = keywordStats.filter(item => item.count > 0).length;

            if (bodyLength < 1200) {
                score -= 18;
                actionItems.push('본문이 짧은 편입니다. 핵심 경험/정보 문단을 1~2개 추가해보세요.');
            } else if (bodyLength > 7000) {
                score -= 6;
                actionItems.push('본문이 긴 편입니다. 반복 문장을 줄여 가독성을 올려보세요.');
            }

            if (paragraphCount > 0 && paragraphCount < 4) {
                score -= 14;
                actionItems.push('문단 수가 적습니다. 소제목 또는 문단 분리로 읽기 흐름을 개선하세요.');
            }

            if (effectiveKeywords.length > 0) {
                const minTarget = Math.min(3, effectiveKeywords.length);
                if (usedKeywordCount < minTarget) {
                    score -= 20;
                    actionItems.push('핵심 키워드 반영이 약합니다. 도입/중간/마무리에 자연스럽게 분산 배치하세요.');
                }

                const overRepeated = keywordStats.filter(item => item.count >= 7);
                if (overRepeated.length > 0) {
                    score -= 10;
                    actionItems.push('일부 키워드 반복이 과합니다. 유의어를 섞고 불필요 반복을 줄이세요.');
                }
            } else {
                score -= 8;
                actionItems.push('핵심 키워드가 비어 있습니다. 작성 보조 정보에 우선 키워드를 입력해보세요.');
            }

            const hypeMatches = draft.match(/(최고|무조건|1등|1위|절대|역대급|완벽|필수구매)/gi) || [];
            if (hypeMatches.length >= 2) {
                score -= 12;
                actionItems.push('과장 표현이 많은 편입니다. 신뢰형 문장으로 조정하세요.');
            }

            const spamBaitTerms = ['대출', '코인', '투자', '주식', '카지노', '성형', '다이어트', '보험'];
            const unrelatedTerms = spamBaitTerms.filter(term =>
                draft.includes(term) && !topic.includes(term) && !effectiveKeywords.some(k => k.includes(term))
            );
            if (unrelatedTerms.length > 0) {
                score -= 12;
                actionItems.push(`무관 키워드 의심 표현(${unrelatedTerms.join(', ')})이 보입니다. 주제 관련 표현만 남기세요.`);
            }

            const hashtags = (draft.match(/#[가-힣a-zA-Z0-9_]+/g) || []).map(tag => tag.replace(/^#/, '').toLowerCase());
            const unrelatedHashtags = hashtags.filter(tag => {
                if (!tag) return false;
                if (topicSignals.has(tag)) return false;
                return ![...topicSignals].some(signal =>
                    signal.length >= 2 && (tag.includes(signal) || signal.includes(tag))
                );
            });
            if (hashtags.length > 0 && unrelatedHashtags.length >= Math.max(2, Math.ceil(hashtags.length * 0.4))) {
                score -= 10;
                actionItems.push('해시태그 중 무관 태그 비중이 높습니다. 본문 핵심 주제 기반 태그로 정리하세요.');
            }

            if (draft && !/[0-9]/.test(draft)) {
                score -= 6;
                actionItems.push('가격/시간/거리 같은 수치 정보가 부족할 수 있습니다. 신뢰 포인트를 추가해보세요.');
            }

            score = Math.max(0, Math.min(100, score));
            updateSeoScoreBadge(score);

            const keywordLines = keywordStats.length
                ? keywordStats.map(item => `- ${item.keyword}: ${item.count}회`).join('\n')
                : '- (키워드 없음)';
            const hashtagSummary = hashtags.length
                ? `- 총 ${hashtags.length}개 / 무관 의심 ${unrelatedHashtags.length}개`
                : '- 해시태그 없음';
            const hypeSummary = hypeMatches.length
                ? `- 과장 표현 ${hypeMatches.length}회`
                : '- 과장 표현 없음';

            const actionText = actionItems.length
                ? actionItems.map((item, idx) => `${idx + 1}. ${item}`).join('\n')
                : '1. 현재 구성은 전반적으로 안정적입니다. 게시 전 사실/표기만 최종 확인하세요.';

            const markdown = `
### 3. 노출 가능성 점검 결과: ${score}점
- 타깃 독자: ${targetReader}
- 본문 길이: ${bodyLength}자
- 문단 수: ${paragraphCount}개
- 키워드 사용 키: ${usedKeywordCount}/${effectiveKeywords.length}

#### 키워드 사용 현황
${keywordLines}

#### 품질 신호
${hashtagSummary}
${hypeSummary}

#### 바로 보완할 점
${actionText}
            `;

            setAssistContentMarkdown(markdown, `3단계 점검 완료 (${score}점)`);
        }

        function runExternalRiskCheck() {
            if (!isExternalRiskPanelOpen) {
                setExternalRiskPanel(true);
            }

            const factors = [
                { id: 'riskCompetitionInput', label: '키워드 경쟁도', weight: 0.35 },
                { id: 'riskSeasonalityInput', label: '시즌성', weight: 0.20 },
                { id: 'riskSaturationInput', label: '주제 포화도', weight: 0.20 },
                { id: 'riskTimingInput', label: '발행 타이밍', weight: 0.15 },
                { id: 'riskActivityInput', label: '최근 활동성', weight: 0.10 }
            ];

            let riskScore = 0;
            const detailLines = [];
            const actions = [];

            for (const factor of factors) {
                const el = document.getElementById(factor.id);
                const val = Number(el?.value || 55);
                const safeVal = Number.isFinite(val) ? Math.max(0, Math.min(100, val)) : 55;
                riskScore += safeVal * factor.weight;
                detailLines.push(`- ${factor.label}: ${Math.round(safeVal)}점`);

                if (safeVal >= 80) {
                    if (factor.id === 'riskCompetitionInput') {
                        actions.push('경쟁도가 높습니다. 세부 키워드(지역/상황/대상)를 더 구체화하세요.');
                    } else if (factor.id === 'riskSeasonalityInput') {
                        actions.push('시즌성이 낮습니다. 현재 시점과 연결되는 수요 포인트를 추가하세요.');
                    } else if (factor.id === 'riskSaturationInput') {
                        actions.push('주제 포화도가 높습니다. 비교 기준이나 개인 경험 포인트를 더 분명히 쓰세요.');
                    } else if (factor.id === 'riskTimingInput') {
                        actions.push('발행 타이밍이 아쉽습니다. 방문자 활동 시간대에 맞춰 예약 발행을 검토하세요.');
                    } else if (factor.id === 'riskActivityInput') {
                        actions.push('최근 활동성이 낮습니다. 발행 주기 안정화가 필요합니다.');
                    }
                }
            }

            riskScore = Math.round(Math.max(0, Math.min(100, riskScore)));
            updateExternalRiskBadge(riskScore);

            let bandText = '보통';
            if (riskScore <= 39) bandText = '낮음';
            else if (riskScore >= 70) bandText = '높음';

            const actionText = actions.length
                ? actions.map((item, idx) => `${idx + 1}. ${item}`).join('\n')
                : '1. 외부 리스크는 비교적 안정적입니다. 내부 품질 점검 결과를 우선 반영하세요.';

            const markdown = `
### 4. 외부 환경 리스크 점검 결과: ${riskScore}점 (${bandText})
${detailLines.join('\n')}

#### 대응 가이드
${actionText}
            `;

            setAssistContentMarkdown(markdown, `외부 리스크 점검 완료 (${riskScore}점)`);
        }

        function getOutputTextForCount() {
            const output = document.getElementById('outputContent');
            if (!output) return '';

            // The initial placeholder block is decorative and should not count.
            if (output.querySelector('.select-none')) return '';

            return output.innerText || '';
        }

        function updateCharCount() {
            const text = getOutputTextForCount();
            const withSpace = text.length;
            const withoutSpace = text.replace(/\s/g, '').length;

            const withSpaceEl = document.getElementById('charCountWithSpace');
            const withoutSpaceEl = document.getElementById('charCountWithoutSpace');
            if (withSpaceEl) withSpaceEl.textContent = String(withSpace);
            if (withoutSpaceEl) withoutSpaceEl.textContent = String(withoutSpace);
        }

        function setupCharCounter() {
            const output = document.getElementById('outputContent');
            if (!output) return;

            output.addEventListener('input', updateCharCount);
            output.addEventListener('keyup', updateCharCount);
            output.addEventListener('paste', () => setTimeout(updateCharCount, 0));

            const observer = new MutationObserver(() => updateCharCount());
            observer.observe(output, { childList: true, subtree: true, characterData: true });
        }

        function normalizeBlogId(inputVal) {
            let value = (inputVal || '').trim();
            if (!value) return '';

            value = value.replace(/^https?:\/\//i, '');

            if (value.includes('blog.naver.com/')) {
                const parts = value.split('blog.naver.com/');
                if (parts[1]) value = parts[1];
            }

            value = value.split('/')[0].split('?')[0].trim();
            return value;
        }

        function getCurrentBlogId() {
            const fromStorage = localStorage.getItem('naver_blog_id') || '';
            return normalizeBlogId(fromStorage);
        }

        function getInputBlogId() {
            const fromInput = document.getElementById('blogIdInput')?.value || '';
            return normalizeBlogId(fromInput);
        }

        function getToneCacheKey(blogId) {
            return `${TONE_CACHE_PREFIX}${blogId}`;
        }

        function setToneStatus(message, isError = false) {
            const statusEls = document.querySelectorAll('[data-tone-status]');
            if (!statusEls.length) return;

            statusEls.forEach((el) => {
                el.textContent = message;
                el.classList.remove('text-red-500', 'text-gray-500');
                el.classList.add(isError ? 'text-red-500' : 'text-gray-500');
            });
        }

        function cleanRssDescription(raw) {
            if (!raw) return '';
            return raw
                .replace(/<img[^>]*>/gi, ' ')
                .replace(/<[^>]+>/g, ' ')
                .replace(/&nbsp;|&#160;/gi, ' ')
                .replace(/&amp;/gi, '&')
                .replace(/&quot;/gi, '"')
                .replace(/&#39;/gi, "'")
                .replace(/\s+/g, ' ')
                .trim();
        }

        function clipText(text, maxLength = 160) {
            if (!text) return '';
            if (text.length <= maxLength) return text;
            return `${text.slice(0, maxLength).trim()}...`;
        }

        function countPattern(text, regex) {
            const matched = text.match(regex);
            return matched ? matched.length : 0;
        }

        function extractFrequentTokens(samples) {
            const stopWords = new Set([
                '후기', '추천', '내돈내산', '직접', '사용', '방문', '위치', '매장', '분위기', '메뉴',
                '리뷰', '홍또연'
            ]);

            const counts = new Map();
            const sourceText = samples.map(s => `${s.title} ${s.body}`).join(' ');
            const cleaned = sourceText.replace(/[^\uAC00-\uD7A30-9\s]/g, ' ');
            const tokens = cleaned.split(/\s+/).filter(Boolean);

            for (const token of tokens) {
                if (token.length < 2) continue;
                if (/^\d+$/.test(token)) continue;
                if (stopWords.has(token)) continue;
                counts.set(token, (counts.get(token) || 0) + 1);
            }

            return [...counts.entries()]
                .sort((a, b) => b[1] - a[1])
                .slice(0, 8)
                .map(([word]) => word);
        }

        function buildToneProfile(blogId, samples) {
            const combinedText = samples.map(s => s.body).join(' ');
            const introRate = samples.filter(s => /^안녕하세요/.test(s.body)).length / Math.max(samples.length, 1);
            const firstPersonCount = countPattern(combinedText, /(저는|저희|우리|남편|제가)/g);
            const laughCount = countPattern(combinedText, /(ㅎㅎ|ㅋㅋ|:\)|\^_\^)/g);
            const startPhraseCount = countPattern(combinedText, /(바로 시작해 보겠습니다|후기 바로 시작)/g);
            const yoEndingCount = countPattern(combinedText, /요[.!?]?/g);
            const formalEndingCount = countPattern(combinedText, /(습니다|했습니다|드립니다)/g);

            const styleGuide = [];
            if (introRate >= 0.3) styleGuide.push('도입은 짧은 인사로 시작');
            styleGuide.push('1인칭 실제 경험 중심 서술');
            styleGuide.push('정보 전달이 분명한 후기 톤 유지');
            styleGuide.push('구성: 도입 -> 핵심정보 -> 경험리뷰 -> 마무리');
            if (startPhraseCount > 0) styleGuide.push('연결 문장을 자연스럽게 활용');
            if (laughCount > 0) styleGuide.push('가벼운 구어체(ㅎㅎ/ㅋㅋ)는 소량만 사용');
            if (yoEndingCount >= formalEndingCount) styleGuide.push('종결어미는 해요체 중심');
            else styleGuide.push('종결어미는 합니다체 중심');
            if (firstPersonCount === 0) styleGuide.push('체험 주체를 문장에 명시');

            const keywords = extractFrequentTokens(samples);
            const snippets = samples.slice(0, 3).map(s => `${s.title}: ${clipText(s.body, 120)}`);

            return {
                blogId,
                analyzedAt: new Date().toISOString(),
                sampleCount: samples.length,
                keywords,
                snippets,
                styleGuide
            };
        }

        async function fetchTextWithCorsFallback(targetUrl) {
            const proxyGetters = [
                (u) => `https://api.allorigins.win/get?url=${encodeURIComponent(u)}`,
                (u) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(u)}`,
                (u) => `https://corsproxy.io/?${encodeURIComponent(u)}`
            ];

            try {
                const direct = await fetch(targetUrl);
                if (direct.ok) return await direct.text();
            } catch (_) { }

            for (const makeProxyUrl of proxyGetters) {
                try {
                    const proxyUrl = makeProxyUrl(targetUrl);
                    const response = await fetch(proxyUrl);
                    if (!response.ok) continue;

                    const rawData = await response.text();

                    try {
                        const asJson = JSON.parse(rawData);
                        if (asJson.contents) return asJson.contents;
                    } catch (_) { }

                    if (rawData && rawData.includes('<rss')) return rawData;
                } catch (_) { }
            }

            throw new Error('RSS 데이터 요청 실패 (CORS 또는 네트워크 제한).');
        }

        async function fetchToneProfileFromRss(blogId) {
            const rssUrl = `https://rss.blog.naver.com/${encodeURIComponent(blogId)}.xml`;
            const xmlText = await fetchTextWithCorsFallback(rssUrl);
            const parser = new DOMParser();
            const doc = parser.parseFromString(xmlText, 'text/xml');
            const parseError = doc.querySelector('parsererror');
            if (parseError) throw new Error('RSS 파싱 실패');

            const items = Array.from(doc.querySelectorAll('item')).slice(0, TONE_SAMPLE_COUNT);
            const samples = items.map(item => {
                const title = (item.querySelector('title')?.textContent || '').trim();
                const rawDescription = item.querySelector('description')?.textContent || '';
                return { title, body: cleanRssDescription(rawDescription) };
            }).filter(s => s.title && s.body.length >= 30);

            if (samples.length < 2) throw new Error('분석용 공개 글이 충분하지 않습니다.');
            return buildToneProfile(blogId, samples);
        }

        function getTonePromptSection(profile) {
            if (!profile) return '';

            const keywordText = profile.keywords.length ? profile.keywords.join(', ') : '없음';
            const styleText = profile.styleGuide.map(line => `- ${line}`).join('\n');
            const snippetText = profile.snippets.map((line, idx) => `${idx + 1}. ${line}`).join('\n');

            return `
                [블로그 말투 프로필]
                블로그 ID: ${profile.blogId}
                샘플 글 수: ${profile.sampleCount}
                핵심 키워드: ${keywordText}
                주의: 아래는 스타일 참조용이며, 기존 문장을 그대로 복제하지 않는다.
                스타일 규칙:
                ${styleText}
                문장 샘플:
                ${snippetText}
            `;
        }

        function getWriterPromptContextSection() {
            const { topic, targetReader, manualKeywords, effectiveKeywords } = getWriterContext();
            const manualKeywordText = manualKeywords.length ? manualKeywords.join(', ') : '(사용자 직접 입력 없음)';
            const effectiveKeywordText = effectiveKeywords.length ? effectiveKeywords.join(', ') : '(추출 키워드 없음)';
            return `
                [작성자 입력 컨텍스트]
                주제/메모: ${topic || '(미입력)'}
                타깃 독자: ${targetReader}
                사용자 우선 키워드: ${manualKeywordText}
                추천 키워드 후보: ${effectiveKeywordText}
            `;
        }

        function updateToneStatusFromCache() {
            const blogId = getCurrentBlogId();
            if (!blogId) {
                activeToneProfile = null;
                setToneStatus('말투 프로필: 블로그 ID를 설정하면 자동 적용됩니다.');
                return;
            }

            const cachedRaw = localStorage.getItem(getToneCacheKey(blogId));
            if (!cachedRaw) {
                activeToneProfile = null;
                setToneStatus('말투 프로필: 아직 분석하지 않았습니다.');
                return;
            }

            try {
                const cached = JSON.parse(cachedRaw);
                const ageMs = Date.now() - new Date(cached.analyzedAt).getTime();
                if (!cached.analyzedAt || Number.isNaN(ageMs) || ageMs > TONE_CACHE_TTL_MS) {
                    activeToneProfile = null;
                    setToneStatus('말투 프로필: 만료됨 (재분석 권장)');
                    return;
                }

                activeToneProfile = cached;
                const dateText = new Date(cached.analyzedAt).toLocaleString();
                setToneStatus(`말투 프로필 준비됨: ${cached.sampleCount}개 글 기준 (${dateText})`);
            } catch (_) {
                activeToneProfile = null;
                setToneStatus('말투 프로필: 캐시 읽기 실패', true);
            }
        }

        async function ensureToneProfile(forceRefresh = false) {
            const blogId = getCurrentBlogId();
            if (!blogId) return null;

            const cacheKey = getToneCacheKey(blogId);
            if (!forceRefresh) {
                const cachedRaw = localStorage.getItem(cacheKey);
                if (cachedRaw) {
                    try {
                        const cached = JSON.parse(cachedRaw);
                        const ageMs = Date.now() - new Date(cached.analyzedAt).getTime();
                        if (cached.analyzedAt && !Number.isNaN(ageMs) && ageMs <= TONE_CACHE_TTL_MS) {
                            activeToneProfile = cached;
                            return cached;
                        }
                    } catch (_) { }
                }
            }

            setToneStatus('말투 프로필 분석 중...');
            const profile = await fetchToneProfileFromRss(blogId);
            activeToneProfile = profile;
            localStorage.setItem(cacheKey, JSON.stringify(profile));
            updateToneStatusFromCache();
            return profile;
        }

        async function refreshToneProfile() {
            const inputBlogId = getInputBlogId();
            const blogId = getCurrentBlogId();
            if (inputBlogId && inputBlogId !== blogId) {
                return alert('먼저 ID 저장을 누른 뒤 프로필 갱신을 실행해주세요.');
            }
            if (!blogId) return alert('먼저 네이버 블로그 아이디를 입력해주세요.');

            showLoading(true, '블로그 말투를 분석하는 중...');
            try {
                const profile = await ensureToneProfile(true);
                if (!profile) throw new Error('말투 프로필 생성 실패');
                alert(`말투 분석 완료 (${profile.sampleCount}개 글 기준)`);
            } catch (e) {
                console.error(e);
                setToneStatus(`말투 프로필 분석 실패: ${e.message}`, true);
                alert(`말투 분석 실패: ${e.message}`);
            } finally {
                showLoading(false);
            }
        }

        function getManagerQuickInputText() {
            return (document.getElementById('managerQuickInput')?.value || '').trim();
        }

        function fillManagerQuickInputFromWriter() {
            const draft = getOutputTextForCount().trim();
            if (!draft) {
                alert('글쓰기 비서 본문이 비어 있습니다. 먼저 초안을 만들어주세요.');
                return;
            }

            const el = document.getElementById('managerQuickInput');
            if (!el) return;
            el.value = draft;
            el.focus();
            el.setSelectionRange(0, 0);
        }

        function clearManagerQuickInput() {
            const el = document.getElementById('managerQuickInput');
            if (!el) return;
            el.value = '';
            el.focus();
        }

        function stripInvisibleUnicode(text) {
            return (text || '').replace(/[\u200B-\u200D\u2060\uFEFF\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, '');
        }

        function copyManagerQuickResult() {
            const el = document.getElementById('managerQuickResult');
            if (!el) return;

            const text = (el.innerText || '').trim();
            if (!text || text.includes('결과가 여기에 표시됩니다')) {
                alert('복사할 교정 결과가 없습니다.');
                return;
            }

            const safeText = stripInvisibleUnicode(text);
            navigator.clipboard.writeText(safeText)
                .then(() => alert('교정 결과를 복사했습니다.'))
                .catch(() => alert('복사에 실패했습니다. 수동으로 복사해주세요.'));
        }

        async function runManagerSpellingCheck() {
            if (!checkKey()) return;

            const content = getManagerQuickInputText();
            if (content.length < 10) {
                alert('맞춤법 검사할 문장을 10자 이상 입력해주세요.');
                return;
            }

            let toneSection = '';
            try {
                const toneProfile = await ensureToneProfile(false);
                toneSection = getTonePromptSection(toneProfile);
            } catch (e) {
                console.warn('Tone profile load failed:', e);
            }

            const prompt = `
                역할: 한국어 블로그 맞춤법 검사 보조자.
                목표: 원문의 의미/톤을 유지하면서 오탈자, 띄어쓰기, 조사만 최소 교정한다.
                중요: 완성 대필 금지. 새 사실 추가 금지. 과장 문구 추가 금지.

                출력 형식:
                [맞춤법 검사본]
                (교정된 문장 전체)

                [수정 포인트]
                - 핵심 수정 3~8개 (왜 수정했는지 한 줄 설명)

                [작성자 확인 질문]
                - 의미가 달라질 수 있는 지점이 있으면 1~2개 질문

                ${toneSection}
                [원문]
                ${content}
            `;

            await callGemini(prompt, [], 'managerQuickResult', '맞춤법 검사 중...');
        }

        async function runManagerSentencePolish() {
            if (!checkKey()) return;

            const content = getManagerQuickInputText();
            if (content.length < 10) {
                alert('다듬을 문장을 10자 이상 입력해주세요.');
                return;
            }

            let toneSection = '';
            try {
                const toneProfile = await ensureToneProfile(false);
                toneSection = getTonePromptSection(toneProfile);
            } catch (e) {
                console.warn('Tone profile load failed:', e);
            }

            const prompt = `
                역할: 블로그 문장 다듬기 보조자.
                목표: 원문 사실은 유지하고, 문장 흐름/가독성만 개선한다.
                중요: 완성 대필 금지. 새 정보 추가 금지. 과장/광고 어투 강화 금지.

                출력 형식:
                [문장 다듬기본]
                (다듬은 문장 전체)

                [개선 근거]
                - 가독성/연결/중복 관점에서 3~6개

                [선택 수정안]
                - 표현이 갈릴 수 있는 문장 2개만 대안 제시

                ${toneSection}
                [원문]
                ${content}
            `;

            await callGemini(prompt, [], 'managerQuickResult', '문장 다듬기 중...');
        }

        function fillAuditInputFromWriterDraft() {
            const draft = getOutputTextForCount().trim();
            if (!draft) {
                alert('글쓰기 비서 본문이 비어 있습니다. 먼저 초안을 만들어주세요.');
                return;
            }

            const el = document.getElementById('auditInput');
            if (!el) return;
            el.value = draft;
            el.focus();
            el.setSelectionRange(0, 0);
        }

        // --- AI Logic (Writer) ---
        async function generatePost() {
            if (!checkKey()) return;
            const writerContext = getWriterContext();
            if (!writerContext.topic && userImages.length === 0) return alert('주제나 사진을 입력해주세요!');

            let toneSection = '';
            try {
                const toneProfile = await ensureToneProfile(false);
                toneSection = getTonePromptSection(toneProfile);
            } catch (e) {
                console.warn('Tone profile load failed:', e);
                setToneStatus(`말투 프로필을 불러오지 못해 기본 모드로 진행합니다: ${e.message}`, true);
            }

            const prompt = `
                역할: 블로그 공동작성(co-writing) 보조자.
                목표: 사용자가 최종 작성을 이어받기 쉽게 구조와 핵심 재료를 제공.
                출력 언어: 한국어.
                중요: 최종 문장 완성은 사용자가 한다. 너는 대필이 아닌 보조자다.

                핵심 원칙:
                1) 완성본을 길게 대신 써주지 않는다.
                2) 확인되지 않은 사실은 꾸며내지 않는다.
                3) 작성자가 채워 넣을 여백(메모/질문)을 남긴다.
                4) 작성자 톤은 모사하되 문장 복붙/복제는 금지한다.

                출력 형식:
                [0] 작성 전 한줄 전략
                - 이번 글의 독자/핵심가치/차별점 요약 1줄

                [1] 포스트 방향 3안
                - 각 안: 독자 포인트 / 중심 메시지 / 제목 1개

                [2] 사진 활용 가이드
                - 사진이 있으면 번호별 배치 제안, 캡션 예시 1줄, 넣을 핵심 포인트 1줄
                - 사진이 없으면 "사진 없이 작성 시 대체 구성" 제시

                [3] 본문 뼈대 (사용자 작성용)
                - 도입 / 중간 3~5문단 / 마무리
                - 각 문단은 2~3문장 메모 형태
                - 문단마다 사용자가 채울 질문 1개

                [4] 바로 쓸 수 있는 짧은 문장 세트
                - 도입 2개 / 전환문 4개 / 마무리 2개
                - 과장/광고 톤 금지

                [5] 작성자 바통 체크리스트 6개

                SEO 가이드:
                - 키워드는 문맥에 맞게 자연스럽게 분산 배치
                - 의미 없는 반복/나열은 금지
                - "내돈내산"은 상황에 맞을 때만
                - 과장 표현(최고, 무조건, 1등)은 지양

                ${toneSection}
                ${getWriterPromptContextSection()}
                사진 개수: ${userImages.length}
            `;

            const ok = await callGemini(
                prompt,
                userImages,
                'outputContent',
                '공동작성용 초안을 준비하는 중...'
            );
            if (ok) {
                updateSeoScoreBadge(null);
                setAssistStatus('초안 생성 완료');
            }
        }

        // --- AI Logic (Spell Check) ---
        async function fixSpelling() {
            if (!checkKey()) return;
            const content = document.getElementById('outputContent').innerText;
            if (!content || content.length < 10) return alert('수정할 내용이 없습니다.');

            let toneSection = '';
            try {
                const toneProfile = await ensureToneProfile(false);
                toneSection = getTonePromptSection(toneProfile);
            } catch (e) {
                console.warn('Tone profile load failed:', e);
                setToneStatus(`말투 프로필을 불러오지 못해 기본 교정으로 진행합니다: ${e.message}`, true);
            }

            const prompt = `
                역할: 한국어 블로그 문장 교정 보조자.
                목표: 글쓴이의 원래 말투를 유지하면서 최소 교정만 수행.

                규칙:
                1) 맞춤법, 띄어쓰기, 어색한 표현만 수정한다.
                2) 문단 구조와 흐름은 최대한 유지한다.
                3) 새 주장이나 과장 문장을 추가하지 않는다.

                스타일 정합성:
                - 아래 말투 프로필을 우선 반영해 교정한다.
                - 표현을 바꿀 때도 작성자 고유 어조를 유지한다.
                ${toneSection}
                ${getWriterPromptContextSection()}

                출력 형식:
                [교정본]
                (전체 문장)

                [선택 수정 포인트]
                - 최대 5개

                [원문]
                ${content}
            `;

            const ok = await callGemini(prompt, [], 'outputContent', '최소 교정 중...');
            if (ok) updateSeoScoreBadge(null);
        }

        async function generatePublishPack() {
            if (!checkKey()) return;

            const draftText = getOutputTextForCount().trim();
            const writerContext = getWriterContext();

            if (!writerContext.topic && draftText.length < 80) {
                return alert('주제 또는 초안 본문이 부족합니다. 먼저 초안을 준비해주세요.');
            }

            // Enhanced UX: Auto-open panel on mobile if closed
            if (window.innerWidth < 1024) {
                setPublishPanelMobileOpen(true);
            }

            let toneSection = '';
            try {
                const toneProfile = await ensureToneProfile(false);
                toneSection = getTonePromptSection(toneProfile);
            } catch (e) {
                console.warn('Tone profile load failed:', e);
            }

            setAssistStatus('AI 발행 요소 생성 중...');

            const prompt = `
                역할: 네이버 블로그 발행 직전 편집 보조자.
                목표: 작성자가 최종 편집을 빠르게 끝낼 수 있게 제목/썸네일/키워드/태그/노출 개선안을 제시.
                전제: 본문 대필 금지. 제안 중심으로만 작성.

                작성 원칙:
                1) 허위/과장/검증불가 정보 금지
                2) 본문 주제와 맞는 제안만 출력
                3) 상업성 과장 표현은 최소화
                4) 사용자에게 실제 도움되는 정보(가격/시간/위치/경험 근거) 우선

                출력 형식:
                [제목 후보]
                - 검색형 5개
                - 공감형 5개
                - 짧은형 3개 (20자 내외)

                [썸네일 제안 3안]
                - 추천 사진 번호(없으면 이미지 콘셉트)
                - 썸네일 문구 (10~16자)
                - 색감/배치 팁 1줄

                [키워드 맵]
                - 메인 키워드 1~2개
                - 서브 키워드 6개
                - 연관 키워드 10개

                [해시태그]
                - 네이버 블로그용 15개
                - 너무 일반적인 태그는 제외
                - 본문 주제와 무관한 태그는 제외

                [노출 개선 체크리스트]
                - 지금 글에서 보완할 7가지
                - 우선순위 High/Medium으로 구분

                ${toneSection}
                ${getWriterPromptContextSection()}
                사진 개수: ${userImages.length}
                현재 초안:
                ${draftText || '(초안 없음)'}
            `;

            const ok = await callGemini(
                prompt,
                [],
                'assistContent',
                '발행 요소 생성 중...'
            );
            if (ok) {
                setAssistStatus('AI 발행 요소 생성 완료');
            } else {
                setAssistStatus('AI 발행 요소 생성 실패', true);
            }
        }

        // --- AI Logic (Audit) ---
        async function fetchAndAuditPost() {
            const url = document.getElementById('auditUrlInput').value.trim();
            if (!url) return alert('URL을 입력해주세요!');

            showLoading(true, "블로그 내용을 가져오고 있습니다... (약 5초 소요)");

            try {
                // 1. Parsing LogNo and BlogId
                let blogId = '';
                let logNo = '';

                if (url.includes('blog.naver.com')) {
                    const parts = url.split('/');
                    const lastPart = parts.pop();
                    const secondLast = parts.pop();

                    if (!isNaN(lastPart)) {
                        logNo = lastPart;
                        blogId = secondLast;
                    }
                }

                if (!logNo || !blogId) {
                    const urlObj = new URL(url);
                    blogId = urlObj.searchParams.get('blogId') || blogId;
                    logNo = urlObj.searchParams.get('logNo') || logNo;
                }

                if (!logNo || !blogId) {
                    throw new Error("네이버 블로그 포스트 주소를 정확히 인식하지 못했습니다.\\n(예: https://blog.naver.com/아이디/게시글번호)");
                }

                // 2. Fetch via CORS Proxy (Fallback Strategy)
                const targetUrl = `https://m.blog.naver.com/${blogId}/${logNo}`;

                // List of proxies to try
                const proxies = [
                    (u) => `https://api.allorigins.win/get?url=${encodeURIComponent(u)}`,
                    (u) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(u)}`,
                    (u) => `https://corsproxy.io/?${encodeURIComponent(u)}`
                ];

                let data = null;
                let success = false;

                for (const proxyGen of proxies) {
                    try {
                        const proxyUrl = proxyGen(targetUrl);
                        const response = await fetch(proxyUrl);
                        if (!response.ok) throw new Error('Network response was not ok');

                        // Handle different proxy response formats
                        const rawData = await response.text();

                        // AllOrigins returns JSON
                        try {
                            const json = JSON.parse(rawData);
                            if (json.contents) {
                                data = json.contents;
                                success = true;
                                break;
                            }
                        } catch (e) {
                            // Valid HTML returned directly (CodeTabs, CorsProxy)
                            if (rawData.includes('<html') || rawData.includes('<div')) {
                                data = rawData;
                                success = true;
                                break;
                            }
                        }
                    } catch (e) {
                        console.warn('Proxy failed:', e);
                        continue;
                    }
                }

                if (!success || !data) throw new Error("모든 우회 경로로 접속을 시도했으나 실패했습니다. (블로그가 비공개이거나 삭제되었을 수 있습니다)");

                // 3. Parse HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(data, 'text/html');

                // 4. Extract Text
                let contentText = "";
                const mainContainer = doc.querySelector('.se-main-container') || doc.querySelector('.post_ct') || doc.body;

                // Remove scripts and styles
                const scripts = mainContainer.querySelectorAll('script, style');
                scripts.forEach(s => s.remove());

                contentText = mainContainer.innerText || mainContainer.textContent;
                contentText = contentText.replace(/\n\s*\n/g, '\n').trim();

                if (contentText.length < 50) throw new Error("본문 내용을 찾지 못했습니다. (이미지 위주의 글이거나 구조가 다름)");

                document.getElementById('auditInput').value = contentText;
                alert("성공적으로 내용을 가져왔습니다! 🚀\n이제 'AI 정밀진단 실행' 버튼을 눌러보세요.");

            } catch (e) {
                console.error(e);
                alert("가져오기 실패 ㅠㅠ\n" + e.message + "\n\n(수동으로 내용을 복사해서 붙여넣어 주세요)");
            } finally {
                showLoading(false);
            }
        }

        async function auditPost() {
            if (!checkKey()) return;
            const content = (document.getElementById('auditInput')?.value || '').trim();
            if (content.length < 80) {
                alert('정밀진단할 본문이 너무 짧습니다. 80자 이상 입력해주세요.');
                return;
            }

            const writerContext = getWriterContext();
            let toneSection = '';
            try {
                const toneProfile = await ensureToneProfile(false);
                toneSection = getTonePromptSection(toneProfile);
            } catch (e) {
                console.warn('Tone profile load failed:', e);
            }

            const prompt = `
                역할: 네이버 블로그 포스팅 코치(보조형).
                목표: 작성자가 최종 수정할 때 바로 적용 가능한 피드백을 제공한다.
                중요 원칙:
                1) 완성 대필 금지, 보조 중심.
                2) 새 사실/수치 추가 금지.
                3) 과장/광고 톤 강화 금지.
                4) 실행 가능한 수정 액션을 우선 제시.

                출력 형식:
                [진단 요약]
                - 강점 2~3개
                - 우선 보완 2~3개

                [점수표 100점]
                - 독자 적합성
                - 도입/전개 흐름
                - 정보 밀도/근거
                - 가독성(문단, 문장 길이)
                - SEO 자연스러움
                - 신뢰성(과장/무관 표현)
                - 총점

                [리스크 감지]
                - 키워드 과다 반복, 과장 표현, 문단 과밀, 무관 해시태그/주제 이탈 여부

                [수정 액션 Top 5]
                - 우선순위(H/M)
                - 수정 위치(도입/중간/마무리)
                - 왜 수정하는지 1문장
                - 바로 적용 가능한 예시 문장 1개(90자 이내)

                [발행 전 체크리스트 7개]
                - 작성자가 최종 확인할 항목만 간결히

                ${toneSection}
                ${getWriterPromptContextSection()}

                [진단 대상 본문]
                ${content}
            `;

            await callGemini(prompt, [], 'auditResult', '포스팅 정밀진단 중...');
        }

        // --- Common API Call ---
        let cachedModelId = null;

        function sanitizeApiKey(raw) {
            return (raw || '').trim();
        }

        function createApiKeyEntry(name, key) {
            return {
                id: `k_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
                name: (name || '').trim(),
                key: sanitizeApiKey(key),
                createdAt: new Date().toISOString()
            };
        }

        function readApiKeyList() {
            const raw = localStorage.getItem(API_KEY_LIST_STORAGE_KEY);
            if (!raw) return [];
            try {
                const parsed = JSON.parse(raw);
                if (!Array.isArray(parsed)) return [];

                return parsed
                    .map(item => ({
                        id: String(item?.id || ''),
                        name: String(item?.name || ''),
                        key: sanitizeApiKey(item?.key || ''),
                        createdAt: String(item?.createdAt || '')
                    }))
                    .filter(item => item.id && item.key);
            } catch (_) {
                return [];
            }
        }

        function writeApiKeyList(list) {
            localStorage.setItem(API_KEY_LIST_STORAGE_KEY, JSON.stringify(list));
        }

        function getActiveApiKeyId() {
            return localStorage.getItem(API_KEY_ACTIVE_ID_STORAGE_KEY) || '';
        }

        function setActiveApiKeyId(id) {
            if (id) localStorage.setItem(API_KEY_ACTIVE_ID_STORAGE_KEY, id);
            else localStorage.removeItem(API_KEY_ACTIVE_ID_STORAGE_KEY);
        }

        function ensureActiveApiKeyExists() {
            const list = readApiKeyList();
            if (!list.length) {
                setActiveApiKeyId('');
                return null;
            }

            const activeId = getActiveApiKeyId();
            const active = list.find(item => item.id === activeId) || list[0];
            if (!activeId || active.id !== activeId) {
                setActiveApiKeyId(active.id);
            }
            return active;
        }

        function getActiveApiKeyEntry() {
            const active = ensureActiveApiKeyExists();
            if (!active) return null;
            return readApiKeyList().find(item => item.id === active.id) || null;
        }

        function maskApiKey(key) {
            const cleaned = sanitizeApiKey(key);
            if (!cleaned) return '';
            if (cleaned.length <= 10) return `${cleaned.slice(0, 2)}***`;
            return `${cleaned.slice(0, 6)}...${cleaned.slice(-4)}`;
        }

        function migrateLegacyApiKeyStorage() {
            const legacyKey = sanitizeApiKey(localStorage.getItem('gemini_api_key'));
            if (!legacyKey) return;

            const list = readApiKeyList();
            const exists = list.some(item => item.key === legacyKey);
            if (!exists) {
                list.unshift(createApiKeyEntry('기존 저장 키', legacyKey));
                writeApiKeyList(list);
            }

            if (!getActiveApiKeyId()) {
                const first = readApiKeyList()[0];
                if (first) setActiveApiKeyId(first.id);
            }

            localStorage.removeItem('gemini_api_key');
        }

        function renderApiKeyManager() {
            const selectEl = document.getElementById('apiKeySelect');
            const statusEl = document.getElementById('apiKeyStatusText');
            const inputEl = document.getElementById('apiKeyInput');
            const aliasEl = document.getElementById('apiKeyAliasInput');
            const useBtn = document.getElementById('useSelectedBtn');
            const removeBtn = document.getElementById('disconnectBtn');
            if (!selectEl || !statusEl) return;

            const list = readApiKeyList();
            const active = ensureActiveApiKeyExists();
            const activeId = active?.id || '';

            selectEl.innerHTML = '';
            if (!list.length) {
                const emptyOpt = document.createElement('option');
                emptyOpt.value = '';
                emptyOpt.textContent = '저장된 API 키 없음';
                selectEl.appendChild(emptyOpt);
                selectEl.disabled = true;
                if (useBtn) useBtn.disabled = true;
                if (removeBtn) removeBtn.disabled = true;
                statusEl.textContent = '활성 API 키가 없습니다. 새 키를 저장해주세요.';
                statusEl.className = 'text-xs text-gray-500 mt-2';
            } else {
                for (const item of list) {
                    const opt = document.createElement('option');
                    opt.value = item.id;
                    const label = item.name ? item.name : '이름 없음';
                    opt.textContent = `${label} · ${maskApiKey(item.key)}`;
                    selectEl.appendChild(opt);
                }

                selectEl.disabled = false;
                selectEl.value = activeId || list[0].id;
                if (useBtn) useBtn.disabled = false;
                if (removeBtn) removeBtn.disabled = false;

                const activeLabel = active?.name || '이름 없음';
                statusEl.textContent = `활성 키: ${activeLabel} (${maskApiKey(active?.key || '')})`;
                statusEl.className = 'text-xs text-gray-500 mt-2';
            }

            if (inputEl) inputEl.value = '';
            if (aliasEl) aliasEl.value = '';
        }

        function getStoredApiKey() {
            return sanitizeApiKey(getActiveApiKeyEntry()?.key || '');
        }

        function getErrorMessageFromResponse(response, data) {
            if (data && data.error && data.error.message) return data.error.message;
            return `HTTP ${response.status} ${response.statusText}`;
        }

        function isGenerationCapableModel(model) {
            const methods = Array.isArray(model?.supportedGenerationMethods) ? model.supportedGenerationMethods : [];
            return methods.includes('generateContent') || methods.includes('generateMessage');
        }

        async function getBestModel(apiKey) {
            // Check cache first (session variable)
            if (cachedModelId) return cachedModelId;

            try {
                // Fetch list of available models
                const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models', {
                    headers: { 'x-goog-api-key': apiKey }
                });
                const data = await response.json().catch(() => ({}));

                if (!response.ok || data.error) throw new Error("API 키 확인 실패: " + getErrorMessageFromResponse(response, data));
                if (!Array.isArray(data.models)) throw new Error("사용 가능한 모델 목록을 불러오지 못했습니다.");

                // 1. Try to find preferred models
                for (const pref of GEMINI_MODEL_PREFERENCES) {
                    const found = data.models.find(m =>
                        m.name?.includes(pref) &&
                        isGenerationCapableModel(m)
                    );
                    if (found) {
                        cachedModelId = found.name.replace('models/', '');
                        console.log(`Found preferred model: ${cachedModelId}`);
                        return cachedModelId;
                    }
                }

                // 2. Fallback: Find ANY model that supports text generation
                const fallback = data.models.find(m => isGenerationCapableModel(m));
                if (fallback) {
                    cachedModelId = fallback.name.replace('models/', '');
                    return cachedModelId;
                }

                throw new Error("글쓰기가 가능한 AI 모델을 찾을 수 없습니다.");

            } catch (e) {
                console.warn("Model discovery failed:", e);
                // Fallback default if list fails
                return DEFAULT_GEMINI_MODEL;
            }
        }

        async function requestGeminiText(prompt, images, loadingMessage = "최적의 AI 모델을 연결하고 있습니다...") {
            const apiKey = getStoredApiKey();
            if (!apiKey) throw new Error("API 키가 없습니다.");

            let modelName = DEFAULT_GEMINI_MODEL;

            showLoading(true, loadingMessage);

            try {
                // Dynamically find the best model for this key
                modelName = await getBestModel(apiKey);
            } catch (e) {
                console.warn("Using default model due to discovery error");
            }

            try {
                const requestBody = { contents: [{ parts: [{ text: prompt }, ...images] }] };
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-goog-api-key': apiKey
                    },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json().catch(() => ({}));

                if (!response.ok || data.error) {
                    throw new Error(`[${modelName}] 오류: ${getErrorMessageFromResponse(response, data)}`);
                }

                const parts = data?.candidates?.[0]?.content?.parts || [];
                const text = parts.map(p => p.text || '').join('\n').trim();
                if (!text) throw new Error(`[${modelName}] 응답 텍스트가 비어 있습니다.`);
                return text;
            } catch (e) {
                throw e;
            } finally {
                showLoading(false);
            }
        }

        async function callGemini(prompt, images, outputId, loadingMessage = "최적의 AI 모델을 연결하고 있습니다...") {
            try {
                const text = await requestGeminiText(prompt, images, loadingMessage);
                const outputEl = document.getElementById(outputId);
                if (!outputEl) throw new Error(`출력 영역을 찾을 수 없습니다: ${outputId}`);
                outputEl.innerHTML = marked.parse(text);
                if (outputId === 'outputContent') updateCharCount();
                return true;
            } catch (e) {
                alert('AI 호출 실패:\n' + e.message + '\n\nAPI 키 권한이나 사용량을 확인해주세요.');
                return false;
            }
        }

        // --- Blog Management ---
        function saveBlogId() {
            const inputEl = document.getElementById('blogIdInput');
            if (!inputEl) return;

            const inputVal = normalizeBlogId(inputEl.value);

            if (inputVal) {
                localStorage.setItem('naver_blog_id', inputVal);
                inputEl.value = inputVal;
                activeToneProfile = null;
                updateToneStatusFromCache();
                alert(`아이디 '${inputVal}' 저장 완료! 📡`);
            } else {
                alert('올바른 네이버 아이디나 블로그 주소를 입력해주세요.');
            }
        }
        function loadBlogId() {
            const id = normalizeBlogId(localStorage.getItem('naver_blog_id'));
            const inputEl = document.getElementById('blogIdInput');
            if (!inputEl) return;
            inputEl.value = id || '';
        }
        function resetToneProfile() {
            const inputBlogId = getInputBlogId();
            const blogId = getCurrentBlogId();
            if (inputBlogId && inputBlogId !== blogId) {
                return alert('먼저 ID 저장을 누른 뒤 초기 리셋을 실행해주세요.');
            }
            if (!blogId) {
                setToneStatus('말투 프로필: 블로그 ID를 먼저 저장해주세요.', true);
                return alert('먼저 네이버 블로그 아이디를 저장해주세요.');
            }

            if (!confirm(`'${blogId}' 말투 프로필 캐시를 초기화할까요?`)) return;

            localStorage.removeItem(getToneCacheKey(blogId));
            activeToneProfile = null;
            setToneStatus('말투 프로필: 초기화됨 (프로필 갱신 버튼으로 재분석 가능)');
            alert('말투 프로필 캐시를 초기화했습니다.');
        }
        function openAnalysis(type) {
            const id = getCurrentBlogId();
            if (!id) return alert('먼저 네이버 아이디를 입력하고 저장해주세요!');

            let url = '';
            if (type === 'blackkiwi') url = `https://blackkiwi.net/`; // BlackKiwi doesn't support direct linking via GET param easily, directing to home
            if (type === 'blogchart') url = `https://www.blogchart.co.kr/`;
            if (type === 'naverstats') url = `https://blog.stat.naver.com/blog/${id}`;

            window.open(url, '_blank');
        }

        // --- Helpers ---
        function checkApiKey() {
            migrateLegacyApiKeyStorage();
            ensureActiveApiKeyExists();
        }
        function checkKey() {
            const key = getStoredApiKey();
            if (!key) {
                alert('설정에서 API 키를 먼저 입력해주세요!');
                const modal = document.getElementById('settingsModal');
                if (modal?.classList.contains('hidden')) toggleSettings();
                return false;
            }
            return true;
        }
        function toggleSettings() {
            const m = document.getElementById('settingsModal');
            if (!m) return;

            const willOpen = m.classList.contains('hidden');
            m.classList.toggle('hidden');
            if (willOpen) {
                loadBlogId();
                updateToneStatusFromCache();
                renderApiKeyManager();
            }
        }
        function saveApiKey() {
            const key = sanitizeApiKey(document.getElementById('apiKeyInput')?.value);
            const alias = (document.getElementById('apiKeyAliasInput')?.value || '').trim();
            if (!key) return alert('API 키를 입력해주세요.');

            if (key.startsWith('sk-')) {
                return alert('이 페이지는 현재 Gemini API 키(AIzaSy...) 전용입니다. GPT를 쓰려면 OpenAI API 연동 코드를 추가해야 합니다.');
            }

            const list = readApiKeyList();
            const existing = list.find(item => item.key === key);
            let activeId = '';

            if (existing) {
                existing.name = alias || existing.name || '저장된 키';
                activeId = existing.id;
            } else {
                const newEntry = createApiKeyEntry(alias || `키 ${list.length + 1}`, key);
                list.unshift(newEntry);
                activeId = newEntry.id;
            }

            writeApiKeyList(list);
            setActiveApiKeyId(activeId);
            cachedModelId = null;
            renderApiKeyManager();
            alert('API 키 저장 완료. 활성 키로 적용되었습니다.');
        }
        function activateSelectedApiKey() {
            const selectEl = document.getElementById('apiKeySelect');
            const selectedId = selectEl?.value || '';
            if (!selectedId) return alert('선택할 API 키가 없습니다.');

            const list = readApiKeyList();
            const target = list.find(item => item.id === selectedId);
            if (!target) return alert('선택한 API 키를 찾지 못했습니다.');

            setActiveApiKeyId(target.id);
            cachedModelId = null;
            renderApiKeyManager();
            alert(`활성 API 키를 '${target.name || '이름 없음'}'으로 변경했습니다.`);
        }
        function disconnectApiKey() {
            const selectEl = document.getElementById('apiKeySelect');
            const selectedId = selectEl?.value || '';
            if (!selectedId) return alert('삭제할 API 키를 선택해주세요.');
            if (!confirm('선택한 API 키를 삭제하시겠습니까?')) return;

            const before = readApiKeyList();
            const next = before.filter(item => item.id !== selectedId);
            if (next.length === before.length) return;

            writeApiKeyList(next);
            if (getActiveApiKeyId() === selectedId) {
                setActiveApiKeyId(next[0]?.id || '');
            }

            cachedModelId = null;
            renderApiKeyManager();
            alert('선택한 API 키를 삭제했습니다.');
        }
        function showLoading(b, msg) {
            const o = document.getElementById('loadingOverlay');
            document.getElementById('loadingText').innerText = msg || "로딩 중...";
            if (b) o.classList.remove('hidden'); else o.classList.add('hidden');
        }
        function copyToClipboard() {
            const raw = document.getElementById('outputContent').innerText;
            const safeText = stripInvisibleUnicode(raw);
            navigator.clipboard.writeText(safeText).then(() => alert('복사 완료!'));
        }
        function downloadAsFile() { /* simplified for brevity */
            const raw = document.getElementById('outputContent').innerText;
            const c = stripInvisibleUnicode(raw);
            const b = new Blob([c], { type: 'text/plain' });
            const u = window.URL.createObjectURL(b);
            const a = document.createElement('a'); a.href = u; a.download = 'blog.txt'; a.click();
        }
        function setPublishPanelMobileOpen(open) {
            const panel = document.getElementById('publishPanelContent');
            const btn = document.getElementById('publishPanelToggleBtn');
            if (!panel || !btn) return;

            if (window.innerWidth >= 1024) {
                panel.classList.remove('is-open');
                panel.style.maxHeight = '';
                panel.style.opacity = '';
                btn.textContent = '열기';
                btn.setAttribute('aria-expanded', 'true');
                return;
            }

            const shouldOpen = Boolean(open);
            panel.classList.toggle('is-open', shouldOpen);
            btn.textContent = shouldOpen ? '닫기' : '열기';
            btn.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
        }

        function togglePublishPanelMobile() {
            if (window.innerWidth >= 1024) return;
            const panel = document.getElementById('publishPanelContent');
            if (!panel) return;
            setPublishPanelMobileOpen(!panel.classList.contains('is-open'));
        }

        // Keep panel state sane when viewport switches between mobile and desktop.
        window.addEventListener('resize', () => {
            setPublishPanelMobileOpen(false);
        });
    </script>
</body>

</html>
